import type Serde from './protocol';
import type Reader from './reader';
import type Writer from './writer';
export declare const SERDE: unique symbol;
export declare const SUBSERDE: unique symbol;
export type TypeMap = {
    [subprotocol: string]: unknown;
};
export interface SubProtocol<T = unknown> {
    serialize: Serializer<T>;
    deserialize: Deserializer<T>;
}
export type DataObject<T> = {
    [SERDE]: 'data-object';
} & T;
export type DeserializedData<T> = T extends object ? T extends (infer E)[] ? DeserializedData<E>[] : {
    [k in keyof T & (string | number) as T[k] extends (symbol | Function) ? never : k]: T[k] extends DataObject<{}> ? DeserializedData<T[k]> : T[k] extends object ? Reference : T[k];
} : T;
/** A Serializer writes `value` to `writer` in a format which allows its corresponding `Deserializer` to restore it again. */
export type Serializer<T, M extends TypeMap = any, Ctx = {}> = (ctx: SerializeContext<M, Ctx>, writer: Writer, value: T) => void;
/** A Deserializer reads a value from `reader` in a format determined by its corresponding `Serializer`. */
export type Deserializer<T, M extends TypeMap = any, Ctx = {}> = (ctx: DeserializeContext<M, Ctx>, reader: Reader) => T;
export declare class SerializeContext<M extends TypeMap = any, Ctx = {}> {
    serde: Serde<M, Ctx>;
    refs: References;
    constructor(serde: Serde<M, Ctx>);
    ref: RefWrapper;
}
export declare class DeserializeContext<M extends TypeMap = any, Ctx = {}> {
    serde: Serde<M, Ctx>;
    refs: Set<DeReference>;
    constructor(serde: Serde<M, Ctx>, refs?: Set<DeReference>);
    /** "Dereference" the given reference. `substitute` will be called with the actual object reference value. */
    deref: (ref: any, substitute: DeReference['substitute']) => void;
}
/** Collection of references, optimized for continuous processing */
declare class References {
    all: Map<any, Reference>;
    pending: [any, Reference][];
    nextId: number;
    push(value: any, subprotocol?: string): Reference;
    pop: () => [any, Reference] | undefined;
    get size(): number;
}
/** A symbolic reference representing a cyclical object reference.
 * Stores additional data necessary to uniquely identify an object
 * during deserialization, i.e. across sessions.
 */
export declare class Reference {
    readonly id: number;
    /** Subprotocol to apply rather than the default */
    readonly subprotocol?: string | undefined;
    [SERDE]: string;
    constructor(id: number, 
    /** Subprotocol to apply rather than the default */
    subprotocol?: string | undefined);
    static all(deref: DeserializeContext['deref'], refs: any[], callback: (values: any[]) => void): void;
}
type DeReference = {
    id: number;
    substitute(actual: any): void;
};
/** Callback type which injects the `[SERDE]: 'data-object'` property into the given object. */
export type DataWrapper = <T extends object>(value: T) => DataObject<T>;
export type RefWrapper = {
    <T extends DataObject<{}>>(data: T): T;
    (obj: object): Reference;
    <T>(value: T): T;
};
export {};
