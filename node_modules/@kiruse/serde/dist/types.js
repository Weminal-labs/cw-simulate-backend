"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reference = exports.DeserializeContext = exports.SerializeContext = exports.SUBSERDE = exports.SERDE = void 0;
exports.SERDE = Symbol('SERDE');
exports.SUBSERDE = Symbol('SUBSERDE');
;
class SerializeContext {
    constructor(serde) {
        this.serde = serde;
        this.refs = new References();
        // prop method signature overload style
        // so we can pass the method along by itself w/ implied `this`
        this.ref = (value, subprotocol, force = false) => {
            // pass back thru for convenience
            if (!force && (!value || typeof value !== 'object' || value[exports.SERDE] === 'data-object'))
                return value;
            return this.refs.push(value, subprotocol);
        };
    }
}
exports.SerializeContext = SerializeContext;
class DeserializeContext {
    constructor(serde, refs = new Set()) {
        this.serde = serde;
        this.refs = refs;
        /** "Dereference" the given reference. `substitute` will be called with the actual object reference value. */
        this.deref = (ref, substitute) => {
            if (ref instanceof Reference) {
                this.refs.add({
                    id: ref.id,
                    substitute,
                });
            }
            else {
                substitute(ref);
            }
        };
    }
}
exports.DeserializeContext = DeserializeContext;
/** Collection of references, optimized for continuous processing */
class References {
    constructor() {
        this.all = new Map();
        this.pending = [];
        this.nextId = 0;
        this.pop = () => this.pending.pop();
    }
    push(value, subprotocol) {
        if (!this.all.has(value)) {
            const ref = new Reference(this.nextId++, subprotocol);
            this.all.set(value, ref);
            this.pending.push([value, ref]);
        }
        return this.all.get(value);
    }
    get size() { return this.all.size; }
}
/** A symbolic reference representing a cyclical object reference.
 * Stores additional data necessary to uniquely identify an object
 * during deserialization, i.e. across sessions.
 */
class Reference {
    constructor(id, 
    /** Subprotocol to apply rather than the default */
    subprotocol) {
        this.id = id;
        this.subprotocol = subprotocol;
        this[_a] = 'reference';
    }
    static all(deref, refs, callback) {
        // actual values w/o References remaining
        const values = refs.slice();
        // track which refs have been resolved
        // refs which aren't actually references are immediately considered resolved
        const done = refs.map(r => !(r instanceof Reference));
        // helper callback for checking if all references have been resolved
        const check = () => done.reduce((prev, curr) => prev && curr, true);
        // resolve references & re-check
        refs.forEach((ref, i) => {
            if (!(ref instanceof Reference))
                return;
            deref(ref, value => {
                done[i] = true;
                values[i] = value;
                check() && callback(values);
            });
        });
        // check in case no references have been passed
        // in which case above loop & its included check would never be called
        check() && callback(values);
    }
}
exports.Reference = Reference;
_a = exports.SERDE;
