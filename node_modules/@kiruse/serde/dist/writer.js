"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const perf_1 = require("./perf");
const BI0 = BigInt(0);
const BI8 = BigInt(8);
const BI_BYTEMASK = BigInt(0xFF);
/** The Writer helps writing serial data to a binary buffer, advancing
 * a cursor as it does.
 */
class Writer {
    constructor({ size = 0, grow = 1024 } = {}) {
        /** Number of actually written bytes. May diverge from `buffer.length` */
        this.size = 0;
        /** Position at which to write binary data. */
        this.cursor = 0;
        this.buffer = new Uint8Array(size);
        this.grow = grow;
    }
    writeBytes(bytes) {
        this.fit(bytes.length);
        this.buffer.set(bytes, this.advance(bytes.length));
        return this;
    }
    writeBool(bool) {
        return this.writeByte(bool ? 0xFF : 0);
    }
    writeFlags(...flags) {
        if (flags.length > 8)
            throw new Error('Too many flags');
        return this.writeByte(flags.reduce((prev, curr, i) => prev | Number(curr) << (7 - i), 0));
    }
    writeByte(byte) {
        this.fit(1);
        this.buffer[this.advance(1)] = byte;
        return this;
    }
    writeUInt32(num) {
        this.fit(4);
        new DataView(this.buffer.buffer).setUint32(this.cursor, num, true);
        this.advance(4);
        return this;
    }
    writeNumber(num) {
        this.fit(8);
        new DataView(this.buffer.buffer).setFloat64(this.advance(8), num, true);
        return this;
    }
    writeBigint(bi) {
        const neg = bi < BI0;
        bi = bigAbs(bi);
        const bytes = bigSizeOf(bi);
        this.fit(bytes + 5);
        this.writeBool(neg);
        this.writeByte(bytes);
        for (let b = 0; b < bytes; ++b) {
            this.writeByte(Number(bi & BI_BYTEMASK));
            bi = bi >> BI8;
        }
        if (bi !== BI0)
            throw new Error('Failed to serialize bigint');
        return this;
    }
    /** Ensure this Writer's buffer can accommodate an additional `size` bytes. If not, grow. */
    fit(size) {
        if (this.cursor + size > this.buffer.length) {
            this.resize(this.cursor + Math.max(this.grow, size, Math.floor(this.buffer.length / 10)));
        }
        return this;
    }
    resize(newSize) {
        (0, perf_1.measure)('Writer.resize', () => {
            if (this.size < newSize) {
                const buffer = this.buffer;
                this.buffer = new Uint8Array(newSize);
                this.buffer.set(buffer);
            }
            else {
                this.buffer = this.buffer.slice(0, newSize);
            }
        });
        return this;
    }
    /** A specialized variant of `fit` which ensures the internal buffer can hold `size` bytes, and "reserves" the bytes
     * in terms of "bytes written". This is useful for allocating padded binary segments which may or may not actually
     * be physically written to.
     *
     * *Note:* The internal cursor is not moved by this method.
     *
     * *Caveat:* Does not prevent writing more bytes than reserved.
     */
    reserve(size) {
        this.fit(size);
        this.size = Math.max(this.size, this.cursor + size);
        return this;
    }
    /** Advances the internal cursor by n bytes and returns its former value. */
    advance(n) {
        const old = this.cursor;
        this.cursor += n;
        this.size = Math.max(this.cursor, this.size);
        return old;
    }
    compress() {
        return this.resize(this.size);
    }
    seek(offset) {
        this.cursor = Math.max(0, Math.min(offset, this.size));
        return this;
    }
    tell() { return this.cursor; }
}
exports.default = Writer;
function bigSizeOf(bi) {
    bi = bigAbs(bi);
    let n = 0;
    while (bi !== BI0) {
        bi >>= BI8;
        ++n;
    }
    return n;
}
const bigAbs = (bi) => bi < BI0 ? -bi : bi;
