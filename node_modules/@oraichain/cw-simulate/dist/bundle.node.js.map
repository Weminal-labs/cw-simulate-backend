{"version":3,"file":"bundle.node.js","mappings":"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","sources":["webpack://@oraichain/cw-simulate/./src/CWSimulateApp.ts","webpack://@oraichain/cw-simulate/./src/SimulateCosmWasmClient.ts","webpack://@oraichain/cw-simulate/./src/fork.ts","webpack://@oraichain/cw-simulate/./src/index.ts","webpack://@oraichain/cw-simulate/./src/instrumentation/CWSimulateVMInstance.ts","webpack://@oraichain/cw-simulate/./src/modules/bank.ts","webpack://@oraichain/cw-simulate/./src/modules/ibc.ts","webpack://@oraichain/cw-simulate/./src/modules/wasm/contract.ts","webpack://@oraichain/cw-simulate/./src/modules/wasm/error.ts","webpack://@oraichain/cw-simulate/./src/modules/wasm/index.ts","webpack://@oraichain/cw-simulate/./src/modules/wasm/module.ts","webpack://@oraichain/cw-simulate/./src/modules/wasm/wasm-util.ts","webpack://@oraichain/cw-simulate/./src/persist.ts","webpack://@oraichain/cw-simulate/./src/store/index.ts","webpack://@oraichain/cw-simulate/./src/store/transactional.ts","webpack://@oraichain/cw-simulate/./src/types.ts","webpack://@oraichain/cw-simulate/./src/util.ts","webpack://@oraichain/cw-simulate/external commonjs \"@cosmjs/cosmwasm-stargate\"","webpack://@oraichain/cw-simulate/external commonjs \"@cosmjs/crypto\"","webpack://@oraichain/cw-simulate/external commonjs \"@cosmjs/encoding\"","webpack://@oraichain/cw-simulate/external commonjs \"@kiruse/serde\"","webpack://@oraichain/cw-simulate/external commonjs \"@kiruse/serde/dist/types\"","webpack://@oraichain/cw-simulate/external commonjs \"@oraichain/cosmwasm-vm-js\"","webpack://@oraichain/cw-simulate/external commonjs \"@oraichain/immutable\"","webpack://@oraichain/cw-simulate/external commonjs \"eventemitter3\"","webpack://@oraichain/cw-simulate/external commonjs \"protobufjs\"","webpack://@oraichain/cw-simulate/external commonjs \"ts-results\"","webpack://@oraichain/cw-simulate/external node-commonjs \"fs\"","webpack://@oraichain/cw-simulate/external node-commonjs \"path\"","webpack://@oraichain/cw-simulate/webpack/bootstrap","webpack://@oraichain/cw-simulate/webpack/startup"],"sourcesContent":["import {\n  BasicBackendApi,\n  CosmosMsg,\n  Environment,\n  IBackendApi,\n  QuerierBase,\n  BasicKVIterStorage,\n  BinaryKVIterStorage,\n  compare,\n} from '@oraichain/cosmwasm-vm-js';\nimport { Err, Ok, Result } from 'ts-results';\nimport { WasmModule, WasmQuery } from './modules/wasm';\nimport { BankModule, BankQuery } from './modules/bank';\nimport { Transactional, TransactionalLens } from './store/transactional';\nimport { AppResponse, TraceLog } from './types';\nimport { SERDE } from '@kiruse/serde';\nimport { IbcModule } from './modules/ibc';\nimport { DebugFunction } from './instrumentation/CWSimulateVMInstance';\nimport { printDebug } from './util';\nimport { Map, SortedMap } from '@oraichain/immutable';\n\ntype HandleCustomMsgFunction = (msg: CosmosMsg) => Promise<Result<AppResponse, string>>;\nconst DefaultAppResponse = Ok({\n  events: [],\n  data: null,\n});\n\nexport type KVIterStorageRegistry = typeof BasicKVIterStorage | typeof BinaryKVIterStorage;\n\nexport interface CWSimulateAppOptions {\n  chainId: string;\n  bech32Prefix: string;\n  backendApi?: IBackendApi;\n  metering?: boolean;\n  gasLimit?: number;\n  debug?: DebugFunction;\n  handleCustomMsg?: HandleCustomMsgFunction;\n  kvIterStorageRegistry?: KVIterStorageRegistry;\n}\n\nexport type ChainData = {\n  height: number;\n  time: number;\n};\n\nexport class CWSimulateApp {\n  [SERDE] = 'cw-simulate-app' as const;\n  public chainId: string;\n  public bech32Prefix: string;\n  public backendApi: IBackendApi;\n  public debug?: DebugFunction;\n  public readonly env?: Environment;\n  private readonly handleCustomMsg?: HandleCustomMsgFunction; // make sure can not re-assign it\n  public store: TransactionalLens<ChainData>;\n  public readonly kvIterStorageRegistry: KVIterStorageRegistry;\n\n  public wasm: WasmModule;\n  public bank: BankModule;\n  public ibc: IbcModule;\n  public querier: Querier;\n\n  constructor(options: CWSimulateAppOptions) {\n    this.chainId = options.chainId;\n    this.bech32Prefix = options.bech32Prefix;\n    this.backendApi = options.backendApi ?? new BasicBackendApi(this.bech32Prefix);\n    if (options.metering) {\n      this.env = new Environment(this.backendApi, options.gasLimit);\n    }\n\n    this.kvIterStorageRegistry = options.kvIterStorageRegistry ?? BinaryKVIterStorage;\n\n    this.debug = options.debug ?? printDebug;\n    this.handleCustomMsg = options.handleCustomMsg;\n    this.store = new Transactional(this.kvIterStorageRegistry === BinaryKVIterStorage ? SortedMap(compare) : Map())\n      .lens<ChainData>()\n      .initialize({\n        height: 1,\n        time: Date.now() * 1e6,\n      });\n\n    this.wasm = new WasmModule(this);\n    this.bank = new BankModule(this);\n    this.ibc = new IbcModule(this);\n    this.querier = new Querier(this);\n  }\n\n  public get gasUsed() {\n    return this.env?.gasUsed ?? 0;\n  }\n\n  public get gasLimit() {\n    return this.env?.gasLimit ?? 0;\n  }\n\n  public async handleMsg(\n    sender: string,\n    msg: CosmosMsg,\n    traces: TraceLog[] = []\n  ): Promise<Result<AppResponse, string>> {\n    if ('wasm' in msg) {\n      return await this.wasm.handleMsg(sender, msg.wasm, traces);\n    }\n    if ('bank' in msg) {\n      return await this.bank.handleMsg(sender, msg.bank);\n    }\n    if ('ibc' in msg) {\n      return await this.ibc.handleMsg(sender, msg.ibc);\n    }\n    // not yet implemented, so use custom fallback assignment\n    if ('stargate' in msg || 'custom' in msg || 'gov' in msg || 'staking' in msg || 'distribution' in msg) {\n      // make default response to keep app working\n      return this.handleCustomMsg?.(msg) ?? DefaultAppResponse;\n    }\n\n    return Err(`unknown message: ${JSON.stringify(msg)}`);\n  }\n\n  public pushBlock<T>(callback: () => Result<T, string>): Result<T, string>;\n  public pushBlock<T>(callback: () => Promise<Result<T, string>>): Promise<Result<T, string>>;\n  public pushBlock<T>(\n    callback: () => Result<T, string> | Promise<Result<T, string>>\n  ): Result<T, string> | Promise<Result<T, string>> {\n    //@ts-ignore\n    return this.store.tx(setter => {\n      setter('height')(this.height + 1);\n      // if height or time are alredy increased, we will wait for it, this will help simulating future moment\n      const current = Date.now() * 1e6;\n      if (this.time < current) {\n        setter('time')(current); // 1 millisecond = 1e6 nano seconds\n      }\n      return callback();\n    });\n  }\n\n  get height() {\n    return this.store.get('height');\n  }\n  get time() {\n    return this.store.get('time');\n  }\n}\n\nexport type QueryMessage = { bank: BankQuery } | { wasm: WasmQuery };\n\nexport class Querier extends QuerierBase {\n  constructor(public readonly app: CWSimulateApp) {\n    super();\n  }\n\n  handleQuery(query: QueryMessage): any {\n    if ('bank' in query) {\n      return this.app.bank.handleQuery(query.bank);\n    } else if ('wasm' in query) {\n      return this.app.wasm.handleQuery(query.wasm);\n    } else {\n      throw new Error('Unknown query message');\n    }\n  }\n}\n","import {\n  SigningCosmWasmClient,\n  ExecuteResult,\n  InstantiateOptions,\n  InstantiateResult,\n  JsonObject,\n  UploadResult,\n  DeliverTxResponse,\n  toBinary,\n  Contract,\n  CodeDetails,\n  Code,\n  ExecuteInstruction,\n  MigrateResult,\n} from '@cosmjs/cosmwasm-stargate';\nimport { Account, SequenceResponse, Block } from '@cosmjs/stargate';\nimport { CWSimulateApp, CWSimulateAppOptions } from './CWSimulateApp';\nimport { sha256 } from '@cosmjs/crypto';\nimport { fromBase64, toHex } from '@cosmjs/encoding';\nimport { Map, SortedMap, isMap } from '@oraichain/immutable';\nimport { Coin, StdFee } from '@cosmjs/amino';\nimport { load, save } from './persist';\nimport { getTransactionHash } from './util';\nimport { ContractInfo } from './types';\nimport { BinaryKVIterStorage, compare } from '@oraichain/cosmwasm-vm-js';\nimport { WasmModule } from './modules/wasm';\n\nexport class SimulateCosmWasmClient extends SigningCosmWasmClient {\n  // deserialize from bytes\n  public static async from(bytes: Uint8Array | Buffer): Promise<SimulateCosmWasmClient> {\n    const app = await load(Uint8Array.from(bytes));\n    return new SimulateCosmWasmClient(app);\n  }\n\n  public readonly app: CWSimulateApp;\n  public constructor(appOrOptions: CWSimulateApp | CWSimulateAppOptions) {\n    super(null, null, {});\n    if (appOrOptions instanceof CWSimulateApp) {\n      this.app = appOrOptions;\n    } else {\n      this.app = new CWSimulateApp(appOrOptions);\n    }\n  }\n\n  // serialize to bytes\n  public toBytes(): Uint8Array {\n    return save(this.app);\n  }\n\n  public async loadContract(address: string, info: ContractInfo, data: any) {\n    this.app.wasm.setContractInfo(address, info);\n    this.app.wasm.setContractStorage(\n      address,\n      isMap(data) ? data : this.app.kvIterStorageRegistry === BinaryKVIterStorage ? SortedMap(data, compare) : Map(data)\n    );\n    await this.app.wasm.getContract(address).init();\n  }\n\n  public getChainId(): Promise<string> {\n    return Promise.resolve(this.app.chainId);\n  }\n  public getHeight(): Promise<number> {\n    return Promise.resolve(this.app.height);\n  }\n  public getAccount(searchAddress: string): Promise<Account | null> {\n    return Promise.resolve({\n      address: searchAddress,\n      pubkey: null,\n      accountNumber: 0,\n      sequence: 0,\n    });\n  }\n  public getSequence(_address: string): Promise<SequenceResponse> {\n    return Promise.resolve({\n      accountNumber: 0,\n      sequence: 0,\n    });\n  }\n\n  public getBlock(height?: number): Promise<Block> {\n    return Promise.resolve({\n      id: '',\n      header: {\n        version: {\n          app: 'simulate',\n          block: 'simulate',\n        },\n        height,\n        chainId: this.app.chainId,\n        time: new Date().toString(),\n      },\n      txs: [],\n    });\n  }\n  public getBalance(address: string, searchDenom: string): Promise<Coin> {\n    // default return zero balance\n    const coin = this.app.bank.getBalance(address).find(coin => coin.denom === searchDenom) ?? {\n      denom: searchDenom,\n      amount: '0',\n    };\n    return Promise.resolve(coin);\n  }\n\n  getCodes(): Promise<readonly Code[]> {\n    const codes: Code[] = [];\n    this.app.wasm.forEachCodeInfo((codeInfo, codeId) => {\n      codes.push({\n        id: codeId,\n        creator: codeInfo.creator,\n        checksum: WasmModule.checksumCache[codeId],\n      });\n    });\n\n    return Promise.resolve(codes);\n  }\n\n  public getCodeDetails(codeId: number): Promise<CodeDetails> {\n    const codeInfo = this.app.wasm.getCodeInfo(codeId);\n    const codeDetails = {\n      id: codeId,\n      creator: codeInfo.creator,\n      checksum: WasmModule.checksumCache[codeId],\n      data: codeInfo.wasmCode,\n    };\n    return Promise.resolve(codeDetails);\n  }\n\n  public getContract(address: string): Promise<Contract> {\n    const contract = this.app.wasm.getContractInfo(address);\n\n    return Promise.resolve({\n      address,\n      codeId: contract.codeId,\n      creator: contract.creator,\n      admin: contract.admin,\n      label: contract.label,\n      ibcPortId: undefined,\n    });\n  }\n\n  public sendTokens(\n    senderAddress: string,\n    recipientAddress: string,\n    amount: readonly Coin[],\n    _fee: StdFee | 'auto' | number,\n    _memo?: string\n  ): Promise<DeliverTxResponse> {\n    const res = this.app.bank.send(senderAddress, recipientAddress, (amount as Coin[]) ?? []);\n    return Promise.resolve({\n      height: this.app.height,\n      txIndex: 0,\n      code: res.ok ? 0 : 1,\n      transactionHash: getTransactionHash(this.app.height, res),\n      events: [],\n      rawLog: typeof res.val === 'string' ? res.val : undefined,\n      gasUsed: 66_000,\n      gasWanted: this.app.gasLimit,\n      msgResponses: [], // for cosmos sdk < 0.46\n    });\n  }\n\n  public upload(\n    senderAddress: string,\n    wasmCode: Uint8Array,\n    _fee: StdFee | 'auto' | number,\n    _memo?: string\n  ): Promise<UploadResult> {\n    // import the wasm bytecode\n    const checksum = toHex(sha256(wasmCode));\n    const codeId = this.app.wasm.create(senderAddress, wasmCode);\n    WasmModule.checksumCache[codeId] = checksum;\n    return Promise.resolve({\n      originalSize: wasmCode.length,\n      compressedSize: wasmCode.length,\n      checksum,\n      codeId,\n      logs: [],\n      height: this.app.height,\n      transactionHash: getTransactionHash(this.app.height, checksum),\n      events: [],\n      gasWanted: this.app.gasLimit,\n      gasUsed: wasmCode.length * 10,\n    });\n  }\n\n  public async instantiate(\n    senderAddress: string,\n    codeId: number,\n    msg: JsonObject,\n    label: string,\n    _fee?: StdFee | 'auto' | number,\n    options?: InstantiateOptions\n  ): Promise<InstantiateResult> {\n    // instantiate the contract\n    const contractGasUsed = this.app.gasUsed;\n    // pass checksum to cache build\n    const result = await this.app.wasm.instantiateContract(\n      senderAddress,\n      (options?.funds as Coin[]) ?? [],\n      codeId,\n      msg,\n      label,\n      options?.admin,\n      undefined\n    );\n\n    if (result.err || typeof result.val === 'string') {\n      throw new Error(result.val.toString());\n    }\n\n    // pull out the contract address\n    const contractAddress = result.val.events[0].attributes[0].value;\n    return {\n      contractAddress,\n      logs: [],\n      height: this.app.height,\n      transactionHash: getTransactionHash(this.app.height, result),\n      events: result.val.events,\n      gasWanted: this.app.gasLimit,\n      gasUsed: this.app.gasUsed - contractGasUsed,\n    };\n  }\n\n  /**\n   * Like `execute` but allows executing multiple messages in one transaction.\n   */\n  public async executeMultiple(\n    senderAddress: string,\n    instructions: readonly ExecuteInstruction[],\n    _fee: StdFee | 'auto' | number,\n    _memo?: string\n  ): Promise<ExecuteResult> {\n    const events = [];\n    const contractGasUsed = this.app.gasUsed;\n    const results = await Promise.all(\n      instructions.map(({ contractAddress, funds, msg }) =>\n        this.app.wasm.executeContract(senderAddress, (funds as Coin[]) ?? [], contractAddress, msg)\n      )\n    );\n\n    for (const result of results) {\n      if (result.err || typeof result.val === 'string') {\n        throw new Error(result.val.toString());\n      }\n      events.push(...result.val.events);\n    }\n\n    return {\n      logs: [],\n      height: this.app.height,\n      transactionHash: getTransactionHash(this.app.height, results),\n      events,\n      gasWanted: this.app.gasLimit,\n      gasUsed: this.app.gasUsed - contractGasUsed,\n    };\n  }\n\n  // keep the same interface so that we can switch to real environment\n  public async execute(\n    senderAddress: string,\n    contractAddress: string,\n    msg: JsonObject,\n    fee: StdFee | 'auto' | number,\n    memo?: string,\n    funds?: readonly Coin[]\n  ): Promise<ExecuteResult> {\n    return this.executeMultiple(\n      senderAddress,\n      [\n        {\n          contractAddress,\n          msg,\n          funds,\n        },\n      ],\n      fee,\n      memo\n    );\n  }\n\n  public async migrate(\n    senderAddress: string,\n    contractAddress: string,\n    codeId: number,\n    migrateMsg: JsonObject,\n    _fee: StdFee | 'auto' | number,\n    _memo?: string\n  ): Promise<MigrateResult> {\n    // only admin can migrate the contract\n\n    const { admin } = this.app.wasm.getContractInfo(contractAddress);\n\n    if (admin !== senderAddress) {\n      throw new Error('unauthorized: can not migrate');\n    }\n\n    const contractGasUsed = this.app.gasUsed;\n\n    const result = await this.app.wasm.migrateContract(senderAddress, codeId, contractAddress, migrateMsg);\n\n    if (result.err || typeof result.val === 'string') {\n      throw new Error(result.val.toString());\n    }\n\n    return {\n      logs: [],\n      height: this.app.height,\n      transactionHash: getTransactionHash(this.app.height, result),\n      events: result.val.events,\n      gasWanted: this.app.gasLimit,\n      gasUsed: this.app.gasUsed - contractGasUsed,\n    };\n  }\n\n  public async queryContractRaw(address: string, key: Uint8Array): Promise<Uint8Array | null> {\n    const result = this.app.wasm.handleQuery({ raw: { contract_addr: address, key: toBinary(key) } });\n    return Promise.resolve(fromBase64(toBinary({ ok: result })));\n  }\n\n  public async queryContractSmart(address: string, queryMsg: JsonObject): Promise<JsonObject> {\n    const result = this.app.wasm.query(address, queryMsg);\n    // check is ok or err\n    return result.ok ? Promise.resolve(result.val) : Promise.reject(new Error(result.val));\n  }\n}\n","import path from 'path';\nimport fs from 'fs';\nimport { compare, toNumber } from '@oraichain/cosmwasm-vm-js';\nimport { SimulateCosmWasmClient } from './SimulateCosmWasmClient';\nimport { SortedMap } from '@oraichain/immutable';\n\nexport class BufferStream {\n  private readonly fd: number;\n  private sizeBuf: Buffer;\n\n  constructor(private readonly filePath: string, append: boolean) {\n    if (!append || !fs.existsSync(filePath)) {\n      this.sizeBuf = Buffer.alloc(4);\n      fs.writeFileSync(filePath, this.sizeBuf);\n      this.fd = fs.openSync(filePath, 'r+');\n    } else {\n      this.fd = fs.openSync(filePath, 'r+');\n      this.sizeBuf = Buffer.allocUnsafe(4);\n      fs.readSync(this.fd, this.sizeBuf, 0, 4, 0);\n    }\n  }\n\n  private increaseSize() {\n    for (let i = this.sizeBuf.length - 1; i >= 0; --i) {\n      if (this.sizeBuf[i] === 255) {\n        this.sizeBuf[i] = 0;\n      } else {\n        this.sizeBuf[i]++;\n        break;\n      }\n    }\n  }\n\n  get size() {\n    return this.sizeBuf.readUInt32BE();\n  }\n\n  close() {\n    fs.closeSync(this.fd);\n  }\n\n  write(entries: Array<[Uint8Array, Uint8Array]>) {\n    let n = 0;\n    for (const [k, v] of entries) {\n      n += k.length + v.length + 3;\n    }\n    const outputBuffer = Buffer.allocUnsafe(n);\n    let ind = 0;\n    for (const [k, v] of entries) {\n      outputBuffer[ind++] = k.length;\n      outputBuffer.set(k, ind);\n      ind += k.length;\n      outputBuffer[ind++] = (v.length >> 8) & 0b11111111;\n      outputBuffer[ind++] = v.length & 0b11111111;\n      outputBuffer.set(v, ind);\n      ind += v.length;\n      this.increaseSize();\n    }\n\n    // update size\n    fs.writeSync(this.fd, this.sizeBuf, 0, 4, 0);\n    // append item\n    fs.appendFileSync(this.filePath, outputBuffer);\n  }\n}\n\nexport class BufferIter {\n  private ind: number = 0;\n  private bufInd: number = 0;\n  constructor(private readonly buf: Uint8Array, public readonly size: number) {}\n\n  reset() {\n    this.ind = 0;\n    this.bufInd = 0;\n    return this;\n  }\n\n  next() {\n    if (this.ind === this.size) {\n      return {\n        done: true,\n      };\n    }\n\n    const keyLength = this.buf[this.bufInd++];\n    const k = this.buf.subarray(this.bufInd, (this.bufInd += keyLength));\n    const valueLength = (this.buf[this.bufInd++] << 8) | this.buf[this.bufInd++];\n    const v = this.buf.subarray(this.bufInd, (this.bufInd += valueLength));\n    this.ind++;\n\n    return {\n      value: [k, v],\n    };\n  }\n}\n\nexport class BufferCollection {\n  public readonly size: number;\n  private readonly buf: Uint8Array;\n  constructor(buf: Uint8Array) {\n    // first 4 bytes is for uint32 be\n    this.size = toNumber(buf.subarray(0, 4));\n    this.buf = buf.subarray(4);\n  }\n\n  entries() {\n    return new BufferIter(this.buf, this.size);\n  }\n}\n\nBufferCollection.prototype['@@__IMMUTABLE_KEYED__@@'] = true;\n\n// helper function\nconst downloadState = async (\n  lcd: string,\n  contractAddress: string,\n  writeCallback: Function,\n  endCallback: Function,\n  startAfter?: string,\n  limit = 5000\n) => {\n  let nextKey = startAfter;\n\n  while (true) {\n    const url = new URL(`${lcd}/cosmwasm/wasm/v1/contract/${contractAddress}/state`);\n    url.searchParams.append('pagination.limit', limit.toString());\n    if (nextKey) {\n      url.searchParams.append('pagination.key', nextKey);\n      console.log('nextKey', nextKey);\n    }\n    try {\n      const { models, pagination } = await fetch(url.toString(), { signal: AbortSignal.timeout(30000) }).then(res =>\n        res.json()\n      );\n      writeCallback(models);\n      if (!(nextKey = pagination.next_key)) {\n        return endCallback();\n      }\n    } catch (ex) {\n      await new Promise(r => setTimeout(r, 1000));\n    }\n  }\n};\n\nexport class DownloadState {\n  constructor(public readonly lcd: string, public readonly downloadPath: string) {}\n\n  // if there is nextKey then append, otherwise insert\n  async saveState(contractAddress: string, nextKey?: string) {\n    const bufStream = new BufferStream(path.join(this.downloadPath, `${contractAddress}.state`), !!nextKey);\n    await new Promise(resolve => {\n      downloadState(\n        this.lcd,\n        contractAddress,\n        (chunks: any) => {\n          const entries = chunks.map(({ key, value }) => [Buffer.from(key, 'hex'), Buffer.from(value, 'base64')]);\n          bufStream.write(entries);\n        },\n        resolve,\n        nextKey\n      );\n    });\n    bufStream.close();\n\n    // check contract code\n    const contractFile = path.join(this.downloadPath, contractAddress);\n    if (!fs.existsSync(contractFile)) {\n      const {\n        contract_info: { code_id },\n      } = await fetch(`${this.lcd}/cosmwasm/wasm/v1/contract/${contractAddress}`).then(res => res.json());\n      const { data } = await fetch(`${this.lcd}/cosmwasm/wasm/v1/code/${code_id}`).then(res => res.json());\n      fs.writeFileSync(contractFile, Buffer.from(data, 'base64'));\n    }\n\n    console.log('done');\n  }\n\n  loadStateData(contractAddress: string): SortedMap<Uint8Array, Uint8Array> {\n    const buffer = fs.readFileSync(path.join(this.downloadPath, `${contractAddress}.state`));\n\n    // @ts-ignore\n    return SortedMap.rawPack<Uint8Array, Uint8Array>(new BufferCollection(buffer), compare);\n  }\n\n  async loadState(\n    client: SimulateCosmWasmClient,\n    senderAddress: string,\n    contractAddress: string,\n    label: string,\n    data?: any\n  ) {\n    const { codeId } = await client.upload(\n      senderAddress,\n      fs.readFileSync(path.join(this.downloadPath, contractAddress)),\n      'auto'\n    );\n\n    await client.loadContract(\n      contractAddress,\n      {\n        codeId,\n        admin: senderAddress,\n        label,\n        creator: senderAddress,\n        created: 1,\n      },\n      data ?? this.loadStateData(contractAddress)\n    );\n  }\n}\n","export * from './CWSimulateApp';\nexport * from './SimulateCosmWasmClient';\nexport * from './types';\nexport * from './store';\nexport * from './modules/wasm/error';\nexport * from './persist';\nexport * from './fork';\n\n// re-export from vm-js\nexport * from '@oraichain/cosmwasm-vm-js';\n\n// re-export from ts-results\nexport * from 'ts-results';\n\n// export some extended Immutable structures\nexport { SortedMap, SortedSet } from '@oraichain/immutable';\n","import { VMInstance, Region, IBackend, Environment } from '@oraichain/cosmwasm-vm-js';\nimport { DebugLog } from '../types';\n\nexport type DebugFunction = (log: DebugLog) => void;\n\nexport class CWSimulateVMInstance extends VMInstance {\n  constructor(\n    public logs: Array<DebugLog>,\n    private readonly debugFn: DebugFunction,\n    backend: IBackend,\n    env?: Environment\n  ) {\n    super(backend, env);\n  }\n\n  private processLog(log: DebugLog) {\n    this.logs.push(log);\n    this.debugFn(log);\n  }\n\n  do_db_read(key: Region): Region {\n    const result = super.do_db_read(key);\n    this.processLog({\n      type: 'call',\n      fn: 'db_read',\n      args: {\n        key: key.str,\n      },\n      result: result.str,\n    });\n\n    return result;\n  }\n\n  do_db_write(key: Region, value: Region) {\n    super.do_db_write(key, value);\n    this.processLog({ type: 'call', fn: 'db_write', args: { key: key.str, value: value.str } });\n  }\n\n  do_db_remove(key: Region) {\n    super.do_db_remove(key);\n    this.processLog({\n      type: 'call',\n      fn: 'db_remove',\n      args: { key: key.str },\n    });\n  }\n\n  do_db_scan(start: Region, end: Region, order: number): Region {\n    let result = super.do_db_scan(start, end, order);\n    this.processLog({\n      type: 'call',\n      fn: 'db_scan',\n      args: { start: start.str, end: end.str, order },\n      result: result.str,\n    });\n\n    return result;\n  }\n\n  do_db_next(iterator_id: Region): Region {\n    let result = super.do_db_next(iterator_id);\n    this.processLog({\n      type: 'call',\n      fn: 'db_next',\n      args: { iterator_id: iterator_id.str },\n      result: result.str,\n    });\n\n    return result;\n  }\n\n  do_addr_humanize(source: Region, destination: Region): Region {\n    let result = super.do_addr_humanize(source, destination);\n    this.processLog({\n      type: 'call',\n      fn: 'addr_humanize',\n      args: { source: source.str },\n      result: result.str,\n    });\n\n    return result;\n  }\n\n  do_addr_canonicalize(source: Region, destination: Region): Region {\n    let result = super.do_addr_canonicalize(source, destination);\n    this.processLog({\n      type: 'call',\n      fn: 'addr_canonicalize',\n      args: { source: source.str, destination: destination.str },\n      result: result.str,\n    });\n\n    return result;\n  }\n\n  do_addr_validate(source: Region): Region {\n    let result = super.do_addr_validate(source);\n    this.processLog({\n      type: 'call',\n      fn: 'addr_validate',\n      args: { source: source.str },\n      result: result.str,\n    });\n\n    return result;\n  }\n\n  do_secp256k1_verify(hash: Region, signature: Region, pubkey: Region): number {\n    let result = super.do_secp256k1_verify(hash, signature, pubkey);\n    this.processLog({\n      type: 'call',\n      fn: 'secp256k1_verify',\n      args: {\n        hash: hash.str,\n        signature: signature.str,\n        pubkey: pubkey.str,\n      },\n      result,\n    });\n\n    return result;\n  }\n\n  do_secp256k1_recover_pubkey(msgHash: Region, signature: Region, recover_param: number): Region {\n    let result = super.do_secp256k1_recover_pubkey(msgHash, signature, recover_param);\n    this.processLog({\n      type: 'call',\n      fn: 'secp256k1_recover_pubkey',\n      args: {\n        msgHash: msgHash.str,\n        signature: signature.str,\n        recover_param,\n      },\n      result: result.str,\n    });\n\n    return result;\n  }\n\n  do_abort(message: Region) {\n    super.do_abort(message);\n    this.processLog({\n      type: 'call',\n      fn: 'abort',\n      args: { message: message.read_str() },\n    });\n  }\n\n  do_debug(message: Region) {\n    const messageStr = message.read_str();\n    this.processLog({\n      type: 'call',\n      fn: 'debug',\n      args: { message: messageStr },\n    });\n    super.do_debug(message);\n    // this help for implementing contract debug\n    this.processLog({\n      type: 'print',\n      message: messageStr,\n    });\n  }\n\n  do_ed25519_batch_verify(messages_ptr: Region, signatures_ptr: Region, public_keys_ptr: Region): number {\n    let result = super.do_ed25519_batch_verify(messages_ptr, signatures_ptr, public_keys_ptr);\n    this.processLog({\n      type: 'call',\n      fn: 'ed25519_batch_verify',\n      args: {\n        messages_ptr: messages_ptr.str,\n        signatures_ptr: signatures_ptr.str,\n        pubkeys_ptr: public_keys_ptr.str,\n      },\n      result,\n    });\n\n    return result;\n  }\n\n  do_ed25519_verify(message: Region, signature: Region, pubkey: Region): number {\n    let result = super.do_ed25519_verify(message, signature, pubkey);\n    this.processLog({\n      type: 'call',\n      fn: 'ed25519_verify',\n      args: {\n        message: message.str,\n        signature: signature.str,\n        pubkey: pubkey.str,\n      },\n      result,\n    });\n\n    return result;\n  }\n\n  do_query_chain(request: Region): Region {\n    let result = super.do_query_chain(request);\n    this.processLog({\n      type: 'call',\n      fn: 'query_chain',\n      args: { request: request.str },\n      result: result.str,\n    });\n    return result;\n  }\n\n  /** Reset debug information such as debug messages & call history.\n   *\n   * These should be valid only for individual contract executions.\n   */\n  resetDebugInfo() {\n    this.debugMsgs = [];\n    this.logs = [];\n    return this;\n  }\n}\n","import { Coin } from '@cosmjs/amino';\nimport { Err, Ok, Result } from 'ts-results';\nimport { BankMsg } from '@oraichain/cosmwasm-vm-js';\nimport { CWSimulateApp } from '../CWSimulateApp';\nimport { Transactional, TransactionalLens } from '../store/transactional';\nimport { AppResponse, Snapshot } from '../types';\n\ntype BankData = {\n  balances: Record<string, Coin[]>;\n};\n\nexport type BankQuery =\n  | {\n      balance: {\n        address: string;\n        denom: string;\n      };\n    }\n  | {\n      all_balances: {\n        address: string;\n      };\n    };\n\nexport type BalanceResponse = { amount: Coin };\nexport type AllBalancesResponse = { amount: Coin[] };\n\nexport class BankModule {\n  public readonly store: TransactionalLens<BankData>;\n\n  constructor(public readonly chain: CWSimulateApp) {\n    this.store = this.chain.store.db.lens<BankData>('bank').initialize({\n      balances: {},\n    });\n  }\n\n  public send(sender: string, recipient: string, amount: Coin[]): Result<void, string> {\n    return this.store.tx(() => {\n      let senderBalance = this.getBalance(sender)\n        .map(ParsedCoin.fromCoin)\n        .filter(c => c.amount > 0);\n      const parsedCoins = amount.map(ParsedCoin.fromCoin).filter(c => c.amount > 0);\n\n      // Deduct coins from sender\n      for (const coin of parsedCoins) {\n        const hasCoin = senderBalance.find(c => c.denom === coin.denom);\n\n        if (hasCoin && hasCoin.amount >= coin.amount) {\n          hasCoin.amount -= coin.amount;\n        } else {\n          return Err(`Sender ${sender} has ${hasCoin?.amount ?? 0} ${coin.denom}, needs ${coin.amount}`);\n        }\n      }\n      senderBalance = senderBalance.filter(c => c.amount > 0);\n\n      // Add amount to recipient\n      const recipientBalance = this.getBalance(recipient).map(ParsedCoin.fromCoin);\n      for (const coin of parsedCoins) {\n        const hasCoin = recipientBalance.find(c => c.denom === coin.denom);\n\n        if (hasCoin) {\n          hasCoin.amount += coin.amount;\n        } else {\n          recipientBalance.push(coin);\n        }\n      }\n\n      this.setBalance(\n        sender,\n        senderBalance.map(c => c.toCoin())\n      );\n      this.setBalance(\n        recipient,\n        recipientBalance.map(c => c.toCoin())\n      );\n      return Ok(undefined);\n    });\n  }\n\n  public burn(sender: string, amount: Coin[]): Result<void, string> {\n    return this.store.tx(() => {\n      let balance = this.getBalance(sender).map(ParsedCoin.fromCoin);\n      let parsedCoins = amount.map(ParsedCoin.fromCoin).filter(c => c.amount > 0);\n\n      for (const coin of parsedCoins) {\n        const hasCoin = balance.find(c => c.denom === coin.denom);\n\n        if (hasCoin && hasCoin.amount >= coin.amount) {\n          hasCoin.amount -= coin.amount;\n        } else {\n          return Err(`Sender ${sender} has ${hasCoin?.amount ?? 0} ${coin.denom}, needs ${coin.amount}`);\n        }\n      }\n      balance = balance.filter(c => c.amount > 0);\n\n      this.setBalance(\n        sender,\n        balance.map(c => c.toCoin())\n      );\n      return Ok(undefined);\n    });\n  }\n\n  public mint(sender: string, amount: Coin[]): Result<void, string> {\n    return this.store.tx(() => {\n      let balance = this.getBalance(sender).map(ParsedCoin.fromCoin);\n      let parsedCoins = amount.map(ParsedCoin.fromCoin).filter(c => c.amount > 0);\n\n      for (const coin of parsedCoins) {\n        const hasCoin = balance.find(c => c.denom === coin.denom);\n\n        if (hasCoin) {\n          hasCoin.amount += coin.amount;\n        } else {\n          balance.push(coin);\n        }\n      }\n      balance = balance.filter(c => c.amount > 0);\n\n      this.setBalance(\n        sender,\n        balance.map(c => c.toCoin())\n      );\n      return Ok(undefined);\n    });\n  }\n\n  public setBalance(address: string, amount: Coin[]) {\n    this.store.tx(setter => {\n      setter('balances', address)(amount);\n      return Ok(undefined);\n    });\n  }\n\n  public getBalance(address: string, storage?: Snapshot): Coin[] {\n    return this.lens(storage).getObject('balances', address) ?? [];\n  }\n\n  public getBalances() {\n    return this.store.getObject('balances');\n  }\n\n  public deleteBalance(address: string) {\n    this.store.tx((_, deleter) => {\n      deleter('balances', address);\n      return Ok(undefined);\n    });\n  }\n\n  public async handleMsg(sender: string, msg: BankMsg): Promise<Result<AppResponse, string>> {\n    if ('send' in msg) {\n      const result = this.send(sender, msg.send.to_address, msg.send.amount);\n      return result.andThen(() =>\n        Ok<AppResponse>({\n          events: [\n            {\n              type: 'transfer',\n              attributes: [\n                { key: 'recipient', value: msg.send.to_address },\n                { key: 'sender', value: sender },\n                { key: 'amount', value: JSON.stringify(msg.send.amount) },\n              ],\n            },\n          ],\n          data: null,\n        })\n      );\n    } else if ('burn' in msg) {\n      const result = this.burn(sender, msg.burn.amount);\n      return result.andThen(() =>\n        Ok<AppResponse>({\n          events: [\n            {\n              type: 'burn',\n              attributes: [\n                { key: 'sender', value: sender },\n                { key: 'amount', value: JSON.stringify(msg.burn.amount) },\n              ],\n            },\n          ],\n          data: null,\n        })\n      );\n    } else {\n      return Err('Unknown bank message');\n    }\n  }\n\n  public handleQuery(query: BankQuery): BalanceResponse | AllBalancesResponse {\n    let bankQuery = query;\n    if ('balance' in bankQuery) {\n      let { address, denom } = bankQuery.balance;\n      const hasCoin = this.getBalance(address).find(c => c.denom === denom);\n      return {\n        amount: hasCoin ?? { denom, amount: '0' },\n      };\n    } else if ('all_balances' in bankQuery) {\n      let { address } = bankQuery.all_balances;\n      return {\n        amount: this.getBalance(address),\n      };\n    }\n    throw new Error('Unknown bank query');\n  }\n\n  private lens(storage?: Snapshot) {\n    return storage ? lensFromSnapshot(storage) : this.store;\n  }\n}\n\n/** Essentially a `Coin`, but the `amount` is a `bigint` for more convenient use. */\nexport class ParsedCoin {\n  constructor(public readonly denom: string, public amount: bigint) {}\n\n  toCoin(): Coin {\n    return {\n      denom: this.denom,\n      amount: this.amount.toString(),\n    };\n  }\n\n  static fromCoin(coin: Coin) {\n    return new ParsedCoin(coin.denom, BigInt(coin.amount));\n  }\n}\n\nexport function lensFromSnapshot(snapshot: Snapshot) {\n  return new Transactional(snapshot).lens<BankData>('bank');\n}\n","import { Coin } from '@cosmjs/amino';\nimport { IbcMsg, IbcTimeout } from '@oraichain/cosmwasm-vm-js';\nimport EventEmitter from 'eventemitter3';\nimport { Err, Ok, Result } from 'ts-results';\nimport { CWSimulateApp } from '../CWSimulateApp';\nimport {\n  AppResponse,\n  DebugLog,\n  IbcBasicResponse,\n  IbcChannelCloseMsg,\n  IbcChannelConnectMsg,\n  IbcChannelOpenMsg,\n  IbcChannelOpenResponse,\n  IbcEndpoint,\n  IbcOrder,\n  IbcPacketAckMsg,\n  IbcPacketReceiveMsg,\n  IbcPacketTimeoutMsg,\n  IbcReceiveResponse,\n} from '../types';\nimport { fromBase64, toHex, toUtf8 } from '@cosmjs/encoding';\nimport { sha256 } from '@cosmjs/crypto';\n\nconst DEFAULT_IBC_TIMEOUT = 2000;\ntype IbcMessageType =\n  | 'ibc_channel_open'\n  | 'ibc_channel_connect'\n  | 'ibc_channel_close'\n  | 'ibc_packet_receive'\n  | 'ibc_packet_ack'\n  | 'ibc_packet_timeout'\n  | 'transfer';\n\ntype IbcMessage = {\n  id: string; // unique msg\n  endpoint: IbcEndpoint;\n  counterparty_endpoint: IbcEndpoint;\n  type: IbcMessageType;\n  data: any;\n};\n\n// source chain_id +':' + channel_id =>\ntype ChannelInfo = {\n  channel_id: string;\n  source_port_id: string;\n  port_id: string;\n  version?: string;\n  connection_id?: string;\n  chain: CWSimulateApp;\n};\n\ntype MiddleWareCallback = (msg: IbcMessage, appRes: AppResponse) => Promise<void> | void;\n\nconst emitter = new EventEmitter();\nconst callbacks = new Map<string, [Function, Function, NodeJS.Timeout]>();\nconst relayMap = new Map<string, ChannelInfo>();\nconst middleWares = new Map<string, MiddleWareCallback[]>();\nconst denomMap = new Map<string, string>();\n\nfunction getKey(...args: string[]): string {\n  return args.join(':');\n}\n\nexport type IbcTransferData = {\n  channelId: string;\n  token: Coin;\n  sender: string;\n  receiver: string;\n  timeout: IbcTimeout;\n  memo?: string;\n};\n\nexport const ibcDenom = (port: string, channel: string, denom: string) => {\n  return 'ibc/' + toHex(sha256(toUtf8(`${port}/${channel}/${denom}`))).toUpperCase();\n};\n\nexport class IbcModule {\n  public sequence: number = 0;\n\n  constructor(public readonly chain: CWSimulateApp) {\n    this.handleRelayMsg = this.handleRelayMsg.bind(this);\n  }\n\n  public addMiddleWare(callback: MiddleWareCallback) {\n    middleWares.get(this.chain.chainId).push(callback);\n  }\n\n  public removeMiddelWare(callback: MiddleWareCallback) {\n    const chainMiddleWares = middleWares.get(this.chain.chainId);\n    const findInd = chainMiddleWares.findIndex(c => c === callback);\n    if (findInd !== -1) chainMiddleWares.splice(findInd, 1);\n  }\n\n  // connection is optional: you can set what ever\n  public relay(\n    sourceChannel: string,\n    sourcePort: string,\n    destChannel: string,\n    destPort: string,\n    destChain: CWSimulateApp\n  ) {\n    this.innerRelay(sourceChannel, sourcePort, destChannel, destPort, destChain);\n    destChain.ibc.innerRelay(destChannel, destPort, sourceChannel, sourcePort, this.chain);\n  }\n\n  public getContractIbcPort(address: string): string | null {\n    const contractIbcPort = `wasm.${address}`;\n    for (const channelInfo of relayMap.values()) {\n      if (channelInfo.source_port_id === contractIbcPort) {\n        return contractIbcPort;\n      }\n    }\n    return null;\n  }\n\n  private async handleRelayMsg(msg: IbcMessage) {\n    const [resolve, reject, timer] = callbacks.get(msg.id);\n\n    try {\n      let logs: DebugLog[] = [];\n\n      let appRes: AppResponse = null;\n\n      const { chain: destChain } = relayMap.get(getKey(this.chain.chainId, msg.endpoint.channel_id));\n      const chainMiddleWares = middleWares.get(destChain.chainId);\n      // transfer token via IBC dest denom will be calculated as sha256(channel/port), and check reverse as well\n      if (msg.type === 'transfer') {\n        // ibc_denom := 'ibc/' + sha256('transfer/dest/denom')\n        const ibcMsg = msg.data as IbcTransferData;\n        // burn on source chain, may throw error if not enough balance\n        this.chain.bank.burn(ibcMsg.sender, [ibcMsg.token]);\n        let destDenom: string;\n        if (ibcMsg.token.denom.startsWith('ibc/')) {\n          // need map back, surely if denomMap is not set, the balance is zero as well\n          destDenom = denomMap.get(ibcMsg.token.denom);\n        } else {\n          // calculate dest denom\n          destDenom = ibcDenom('transfer', msg.counterparty_endpoint.channel_id, ibcMsg.token.denom);\n          // create denom map\n          denomMap.set(destDenom, ibcMsg.token.denom);\n        }\n        // mint on dest chain and burn on source chain\n        destChain.bank.mint(ibcMsg.receiver, [{ denom: destDenom, amount: ibcMsg.token.amount }]);\n        appRes = { events: [], data: null };\n      } else if (msg.counterparty_endpoint.port_id.startsWith('wasm.')) {\n        const destContractAddress = msg.counterparty_endpoint.port_id.substring(5); // remove wasm. prefix\n\n        const contract = destChain.wasm.getContract(destContractAddress);\n\n        if (!(msg.type in contract)) {\n          throw new Error(`Contract ${destContractAddress} does not have entrypoint ${msg.type}`);\n        }\n\n        const ret = contract[msg.type](msg.data, logs) as any;\n\n        if (ret.err) {\n          throw new Error(ret.val);\n        }\n\n        // process Ibc response\n        appRes = await destChain.wasm.handleIbcResponse(contract.address, ret.val);\n      } else if (!chainMiddleWares.length) {\n        // we are not focus on IBC implementation at application modules, currently we only focus on IBC contract implementation\n        throw new Error(`Method ${msg.type} has not been implemented on chain ${destChain.chainId}`);\n      }\n\n      // default appRes, so we do not have to merge responses\n      if (!appRes) appRes = { events: [], data: null };\n\n      // run through callback following the order\n      for (const middleware of chainMiddleWares) {\n        await middleware(msg, appRes);\n      }\n      if (resolve) resolve(appRes);\n    } catch (ex) {\n      if (reject) reject(ex);\n    } finally {\n      clearTimeout(timer);\n      callbacks.delete(msg.id);\n    }\n  }\n\n  // currently we only support handleMsg from cosmwasm contract that is IbcMsg, other event will not be covered from this module\n  // it is at application level\n  public async handleMsg(sender: string, msg: IbcMsg): Promise<Result<AppResponse, string>> {\n    if ('send_packet' in msg) {\n      const destInfo = relayMap.get(getKey(this.chain.chainId, msg.send_packet.channel_id));\n      if (!destInfo) {\n        throw new Error('Chain is not relayed yet');\n      }\n\n      const result = await this.chain.store.tx(async () => {\n        try {\n          const result = await this.sendPacketReceive({\n            packet: {\n              data: msg.send_packet.data,\n              src: {\n                port_id: destInfo.source_port_id,\n                channel_id: msg.send_packet.channel_id,\n              },\n              dest: {\n                port_id: destInfo.port_id,\n                channel_id: destInfo.channel_id,\n              },\n              sequence: this.sequence++,\n              timeout: msg.send_packet.timeout,\n            },\n            relayer: sender,\n          });\n          return Ok(result);\n        } catch (ex) {\n          return Err((ex as Error).message);\n        }\n      });\n\n      return result.andThen(ret =>\n        Ok<AppResponse>({\n          ...ret,\n          events: [\n            ...ret.events,\n            {\n              type: 'send_packet',\n              attributes: [\n                { key: 'packet_data_hex', value: toHex(fromBase64(msg.send_packet.data)) },\n                {\n                  key: 'packet_timeout_height',\n                  value: (msg.send_packet.timeout.block?.height ?? 0).toString(),\n                },\n                {\n                  key: 'packet_sequence',\n                  value: this.sequence.toString(),\n                },\n                {\n                  key: 'packet_timeout_timestamp',\n                  value: msg.send_packet.timeout.timestamp ?? '',\n                },\n                {\n                  key: 'packet_src_channel',\n                  value: msg.send_packet.channel_id,\n                },\n                {\n                  key: 'packet_src_port',\n                  value: destInfo.source_port_id,\n                },\n                {\n                  key: 'packet_dest_channel',\n                  value: destInfo.channel_id,\n                },\n                {\n                  key: 'packet_dest_port',\n                  value: destInfo.port_id,\n                },\n                {\n                  key: 'packet_channel_ordering',\n                  value: IbcOrder.Unordered,\n                },\n                {\n                  key: 'connection_id',\n                  value: destInfo.connection_id,\n                },\n                {\n                  key: 'action',\n                  value: 'application-module-defined-field',\n                },\n                {\n                  key: 'module',\n                  value: 'ibc_channel',\n                },\n              ],\n            },\n          ],\n          data: null,\n        })\n      );\n    }\n    if ('transfer' in msg) {\n      const result = await this.chain.store.tx(async () => {\n        try {\n          // channel_id is source channel\n          const msgData: IbcTransferData = {\n            sender,\n            channelId: msg.transfer.channel_id,\n            timeout: msg.transfer.timeout,\n            token: msg.transfer.amount,\n            receiver: msg.transfer.to_address,\n          };\n          const result = await this.sendTransfer(msgData);\n          return Ok(result);\n        } catch (ex) {\n          return Err((ex as Error).message);\n        }\n      });\n\n      return result.andThen(ret =>\n        Ok<AppResponse>({\n          ...ret,\n          events: [\n            ...ret.events,\n            {\n              type: 'transfer',\n              attributes: [\n                { key: 'recipient', value: msg.transfer.to_address },\n                {\n                  key: 'sender',\n                  value: sender,\n                },\n                {\n                  key: 'amount',\n                  value: `${msg.transfer.amount.amount}${msg.transfer.amount.denom}`,\n                },\n                {\n                  key: 'channel',\n                  value: msg.transfer.channel_id,\n                },\n              ],\n            },\n          ],\n          data: null,\n        })\n      );\n    }\n\n    if ('close_channel' in msg) {\n      const destInfo = relayMap.get(getKey(this.chain.chainId, msg.close_channel.channel_id));\n      if (!destInfo) {\n        throw new Error('Chain is not relayed yet');\n      }\n\n      const result = await this.chain.store.tx(async () => {\n        try {\n          // when source channel call handle close msg, we can call sendChannelClose from dest chain to trigger it,\n          const result = await destInfo.chain.ibc.sendChannelClose({\n            close_init: {\n              channel: {\n                order: IbcOrder.Unordered,\n                version: destInfo.version,\n                connection_id: destInfo.connection_id,\n                counterparty_endpoint: {\n                  channel_id: msg.close_channel.channel_id,\n                  port_id: destInfo.source_port_id,\n                },\n                endpoint: {\n                  channel_id: destInfo.channel_id,\n                  port_id: destInfo.port_id,\n                },\n              },\n            },\n          });\n\n          return Ok(result);\n        } catch (ex) {\n          return Err((ex as Error).message);\n        }\n      });\n\n      return result.andThen(ret =>\n        Ok<AppResponse>({\n          ...ret,\n          events: [\n            ...ret.events,\n            {\n              type: 'channel_close_init',\n              attributes: [\n                { key: 'port_id', value: destInfo.source_port_id },\n                {\n                  key: 'channel_id',\n                  value: sender,\n                },\n                {\n                  key: 'counterparty_port_id',\n                  value: destInfo.port_id,\n                },\n                {\n                  key: 'counterparty_channel_id',\n                  value: destInfo.channel_id,\n                },\n                {\n                  key: 'connection_id',\n                  value: destInfo.connection_id,\n                },\n                {\n                  key: 'action',\n                  value: 'channel_close_init',\n                },\n                {\n                  key: 'module',\n                  value: 'ibc_channel',\n                },\n              ],\n            },\n          ],\n          data: null,\n        })\n      );\n    }\n\n    return Err('Unknown ibc message');\n  }\n\n  // this method should be called from relayer, because blockchain can not call other rpc\n  // such as A -> sendChannelOpen(open_init) -> B\n  // if success then B -> sendChannelOpen(open_confirm) -> B\n  // same for sendChannelConnect and sendChannelClose\n  protected sendMsg<T>(\n    type: IbcMessageType,\n    endpoint: IbcEndpoint,\n    counterparty_endpoint: IbcEndpoint,\n    data: any\n  ): Promise<T> {\n    const eventKey = getKey(this.chain.chainId, endpoint.channel_id);\n    const id = Date.now().toString();\n\n    return new Promise<T>((resolve, reject) => {\n      const timer = setTimeout(\n        () => reject(new Error(`Call ${type} timeout after ${DEFAULT_IBC_TIMEOUT}`)),\n        DEFAULT_IBC_TIMEOUT\n      );\n      callbacks.set(id, [resolve, reject, timer]);\n      emitter.emit(eventKey, { type, endpoint, counterparty_endpoint, data, id }); // call handleRelayMsg\n    });\n  }\n\n  protected innerRelay(\n    sourceChannel: string,\n    sourcePort: string,\n    destChannel: string,\n    destPort: string,\n    destChain: CWSimulateApp\n  ) {\n    const eventKey = getKey(this.chain.chainId, sourceChannel);\n    // override\n    relayMap.set(eventKey, {\n      channel_id: destChannel,\n      port_id: destPort,\n      source_port_id: sourcePort,\n      chain: destChain,\n    });\n    // reset all\n    middleWares.set(this.chain.chainId, []);\n    emitter.removeAllListeners(eventKey);\n    emitter.addListener(eventKey, this.handleRelayMsg);\n  }\n\n  public sendChannelOpen(data: IbcChannelOpenMsg): Promise<IbcChannelOpenResponse> {\n    const { endpoint, counterparty_endpoint } = 'open_init' in data ? data.open_init.channel : data.open_try.channel;\n    return this.sendMsg('ibc_channel_open', endpoint, counterparty_endpoint, data);\n  }\n\n  public sendChannelConnect(data: IbcChannelConnectMsg): Promise<IbcBasicResponse> {\n    const { endpoint, counterparty_endpoint } = 'open_ack' in data ? data.open_ack.channel : data.open_confirm.channel;\n\n    // update version\n    if ('open_ack' in data) {\n      const { channel } = data.open_ack;\n      // update version and connection_id (if success? - should implement at wrap method to send open, confirm ack packet)\n      const destInfo = relayMap.get(getKey(this.chain.chainId, channel.endpoint.channel_id));\n      destInfo.version = channel.version;\n      destInfo.connection_id = channel.connection_id;\n      const sourceInfo = relayMap.get(getKey(destInfo.chain.chainId, channel.counterparty_endpoint.channel_id));\n      sourceInfo.version = channel.version;\n      sourceInfo.connection_id = channel.connection_id;\n    }\n    return this.sendMsg('ibc_channel_connect', endpoint, counterparty_endpoint, data);\n  }\n\n  public sendChannelClose(data: IbcChannelCloseMsg): Promise<IbcBasicResponse> {\n    const { endpoint, counterparty_endpoint } =\n      'close_init' in data ? data.close_init.channel : data.close_confirm.channel;\n    return this.sendMsg('ibc_channel_close', endpoint, counterparty_endpoint, data);\n  }\n\n  public sendPacketReceive(data: IbcPacketReceiveMsg): Promise<IbcReceiveResponse> {\n    return this.sendMsg('ibc_packet_receive', data.packet.src, data.packet.dest, data);\n  }\n\n  public sendPacketAck(data: IbcPacketAckMsg): Promise<IbcBasicResponse> {\n    return this.sendMsg('ibc_packet_ack', data.original_packet.src, data.original_packet.dest, data);\n  }\n\n  public sendPacketTimeout(data: IbcPacketTimeoutMsg): Promise<IbcBasicResponse> {\n    return this.sendMsg('ibc_packet_timeout', data.packet.src, data.packet.dest, data);\n  }\n\n  public sendTransfer(data: IbcTransferData): Promise<IbcBasicResponse> {\n    // from source channel => get dest channel\n    const destInfo = relayMap.get(getKey(this.chain.chainId, data.channelId));\n    if (!destInfo) {\n      throw new Error('Chain is not relayed yet');\n    }\n\n    const endpoint: IbcEndpoint = {\n      port_id: destInfo.source_port_id,\n      channel_id: data.channelId,\n    };\n\n    const destEndpoint: IbcEndpoint = {\n      port_id: destInfo.port_id,\n      channel_id: destInfo.channel_id,\n    };\n\n    return this.sendMsg('transfer', endpoint, destEndpoint, data);\n  }\n}\n","import { Coin } from '@cosmjs/amino';\nimport { fromBinary } from '@cosmjs/cosmwasm-stargate';\nimport { ContractResponse, IBackend } from '@oraichain/cosmwasm-vm-js';\nimport { Map } from '@oraichain/immutable';\nimport { Err, Ok, Result } from 'ts-results';\nimport { CWSimulateVMInstance } from '../../instrumentation/CWSimulateVMInstance';\nimport {\n  DebugLog,\n  IbcBasicResponse,\n  IbcChannelCloseMsg,\n  IbcChannelConnectMsg,\n  IbcChannelOpenMsg,\n  IbcChannelOpenResponse,\n  IbcPacketAckMsg,\n  IbcPacketReceiveMsg,\n  IbcPacketTimeoutMsg,\n  IbcReceiveResponse,\n  ReplyMsg,\n  Snapshot,\n} from '../../types';\nimport { fromRustResult } from '../../util';\nimport { ContractNotFoundError } from './error';\nimport { WasmModule } from './module';\n\n/** An interface to interact with CW SCs */\nexport default class Contract {\n  private _vm: CWSimulateVMInstance | undefined;\n\n  constructor(private _wasm: WasmModule, public readonly address: string) {}\n\n  async init() {\n    if (!this._vm) {\n      const { _wasm: wasm, address } = this;\n      const contractInfo = wasm.getContractInfo(address);\n      if (!contractInfo) throw new Error(`Contract ${address} not found`);\n\n      const { codeId } = contractInfo;\n      const codeInfo = wasm.getCodeInfo(codeId);\n      if (!codeInfo) throw new Error(`code ${codeId} not found`);\n\n      const { wasmCode } = codeInfo;\n      const contractState = this.getStorage();\n\n      // @ts-ignore\n      const storage = new wasm.chain.kvIterStorageRegistry(contractState);\n\n      const backend: IBackend = {\n        backend_api: wasm.chain.backendApi,\n        storage,\n        querier: wasm.chain.querier,\n      };\n\n      const logs: DebugLog[] = [];\n      // pass debug reference from wasm.chain, if implemented, check metering when sharing env\n\n      const vm = new CWSimulateVMInstance(logs, msg => wasm.chain.debug?.(msg), backend, wasm.chain.env);\n\n      await vm.build(wasmCode, WasmModule.checksumCache[codeId]);\n\n      this._vm = vm;\n    }\n    return this;\n  }\n\n  instantiate(sender: string, funds: Coin[], instantiateMsg: any, logs: DebugLog[]): Result<ContractResponse, string> {\n    try {\n      if (!this._vm) {\n        return new ContractNotFoundError(this.address);\n      }\n      const vm = this._vm;\n\n      const env = this.getExecutionEnv();\n      const info = { sender, funds };\n\n      const res = fromRustResult<ContractResponse>(vm.instantiate(env, info, instantiateMsg));\n\n      this.setStorage(vm.backend.storage.dict);\n\n      logs.push(...vm.logs);\n\n      return res;\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    }\n  }\n\n  execute(sender: string, funds: Coin[], executeMsg: any, logs: DebugLog[]): Result<ContractResponse, string> {\n    try {\n      if (!this._vm) {\n        return new ContractNotFoundError(this.address);\n      }\n      const vm = this._vm;\n      vm.resetDebugInfo();\n      const env = this.getExecutionEnv();\n      const info = { sender, funds };\n      const res = fromRustResult<ContractResponse>(vm.execute(env, info, executeMsg));\n\n      this.setStorage(vm.backend.storage.dict);\n\n      logs.push(...vm.logs);\n\n      return res;\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    }\n  }\n\n  migrate(migrateMsg: any, logs: DebugLog[]): Result<ContractResponse, string> {\n    try {\n      if (!this._vm) {\n        return new ContractNotFoundError(this.address);\n      }\n      const vm = this._vm;\n      const env = this.getExecutionEnv();\n      const res = fromRustResult<ContractResponse>(vm.migrate(env, migrateMsg));\n\n      this.setStorage(vm.backend.storage.dict);\n\n      logs.push(...vm.logs);\n\n      return res;\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    }\n  }\n\n  reply(replyMsg: ReplyMsg, logs: DebugLog[]): Result<ContractResponse, string> {\n    try {\n      if (!this._vm) {\n        return new ContractNotFoundError(this.address);\n      }\n      const vm = this._vm;\n      const res = fromRustResult<ContractResponse>(vm.reply(this.getExecutionEnv(), replyMsg));\n\n      this.setStorage(vm.backend.storage.dict);\n\n      logs.push(...vm.logs);\n\n      return res;\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    }\n  }\n\n  ibc_channel_open(ibcChannelOpenMsg: IbcChannelOpenMsg, logs: DebugLog[]): Result<IbcChannelOpenResponse, string> {\n    try {\n      if (!this._vm) {\n        return new ContractNotFoundError(this.address);\n      }\n      const vm = this._vm;\n      const res = fromRustResult<IbcChannelOpenResponse>(\n        vm.ibc_channel_open(this.getExecutionEnv(), ibcChannelOpenMsg)\n      );\n\n      this.setStorage(vm.backend.storage.dict);\n\n      logs.push(...vm.logs);\n\n      return res;\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    }\n  }\n\n  ibc_channel_connect(ibcChannelConnectMsg: IbcChannelConnectMsg, logs: DebugLog[]): Result<IbcBasicResponse, string> {\n    try {\n      if (!this._vm) {\n        return new ContractNotFoundError(this.address);\n      }\n      const vm = this._vm;\n      const res = fromRustResult<IbcBasicResponse>(\n        vm.ibc_channel_connect(this.getExecutionEnv(), ibcChannelConnectMsg)\n      );\n\n      this.setStorage(vm.backend.storage.dict);\n\n      logs.push(...vm.logs);\n\n      return res;\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    }\n  }\n\n  ibc_channel_close(ibcChannelCloseMsg: IbcChannelCloseMsg, logs: DebugLog[]): Result<IbcBasicResponse, string> {\n    try {\n      if (!this._vm) {\n        return new ContractNotFoundError(this.address);\n      }\n      const vm = this._vm;\n      const res = fromRustResult<IbcBasicResponse>(vm.ibc_channel_close(this.getExecutionEnv(), ibcChannelCloseMsg));\n\n      this.setStorage(vm.backend.storage.dict);\n\n      logs.push(...vm.logs);\n\n      return res;\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    }\n  }\n\n  ibc_packet_receive(ibcPacketReceiveMsg: IbcPacketReceiveMsg, logs: DebugLog[]): Result<IbcReceiveResponse, string> {\n    try {\n      if (!this._vm) {\n        return new ContractNotFoundError(this.address);\n      }\n      const vm = this._vm;\n      const res = fromRustResult<IbcReceiveResponse>(\n        vm.ibc_packet_receive(this.getExecutionEnv(), ibcPacketReceiveMsg)\n      );\n\n      this.setStorage(vm.backend.storage.dict);\n\n      logs.push(...vm.logs);\n\n      return res;\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    }\n  }\n\n  ibc_packet_ack(ibcPacketAckMsg: IbcPacketAckMsg, logs: DebugLog[]): Result<IbcBasicResponse, string> {\n    try {\n      if (!this._vm) {\n        return new ContractNotFoundError(this.address);\n      }\n      const vm = this._vm;\n      const res = fromRustResult<IbcBasicResponse>(vm.ibc_packet_ack(this.getExecutionEnv(), ibcPacketAckMsg));\n\n      this.setStorage(vm.backend.storage.dict);\n\n      logs.push(...vm.logs);\n\n      return res;\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    }\n  }\n\n  ibc_packet_timeout(ibcPacketTimeoutMsg: IbcPacketTimeoutMsg, logs: DebugLog[]): Result<IbcBasicResponse, string> {\n    try {\n      if (!this._vm) {\n        return new ContractNotFoundError(this.address);\n      }\n      const vm = this._vm;\n      const res = fromRustResult<IbcBasicResponse>(vm.ibc_packet_timeout(this.getExecutionEnv(), ibcPacketTimeoutMsg));\n\n      this.setStorage(vm.backend.storage.dict);\n\n      logs.push(...vm.logs);\n\n      return res;\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    }\n  }\n\n  query(queryMsg: any, store?: Map<string, string>): Result<any, string> {\n    if (!this._vm) {\n      return new ContractNotFoundError(this.address);\n    }\n\n    const vm = this._vm;\n\n    // time travel\n    const currBackend = vm.backend;\n    // @ts-ignore\n    const storage = new this._wasm.chain.kvIterStorageRegistry(this.getStorage(store));\n    vm.backend = {\n      ...vm.backend,\n      storage,\n    };\n\n    let env = this.getExecutionEnv();\n    try {\n      return fromRustResult<string>(vm.query(env, queryMsg)).andThen(v => Ok(fromBinary(v)));\n    } catch (ex) {\n      return Err((ex as Error).message ?? ex.toString());\n    } finally {\n      // reset time travel\n      this._vm.backend = currBackend;\n    }\n  }\n\n  setStorage(value: Map<unknown, unknown>) {\n    this._wasm.setContractStorage(this.address, value);\n  }\n\n  getStorage(storage?: Snapshot): Map<unknown, unknown> {\n    return this._wasm.getContractStorage(this.address, storage);\n  }\n\n  getExecutionEnv() {\n    return this._wasm.getExecutionEnv(this.address);\n  }\n\n  get vm() {\n    return this._vm;\n  }\n  get valid() {\n    return !!this._vm;\n  }\n}\n","import { ErrImpl } from 'ts-results';\n\nexport class VmError extends ErrImpl<string> {\n  constructor(msg: string) {\n    super(`VmError: ${msg}`);\n  }\n}\n\nexport class ContractNotFoundError extends VmError {\n  constructor(contractAddress: string) {\n    super(`contract ${contractAddress} not found`);\n  }\n}\n\n// general error like javascript error\nexport class GenericError extends Error {\n  constructor(msg: string) {\n    super(`Generic error: ${msg}`);\n  }\n}\n","export * from './module';\n","import { fromBinary } from '@cosmjs/cosmwasm-stargate';\nimport { Coin } from '@cosmjs/amino';\nimport { fromBase64, toBase64, toBech32 } from '@cosmjs/encoding';\nimport Immutable, { Map, SortedMap } from '@oraichain/immutable';\nimport { Err, Ok, Result } from 'ts-results';\nimport type { CWSimulateApp } from '../../CWSimulateApp';\nimport { NEVER_IMMUTIFY, Transactional, TransactionalLens } from '../../store/transactional';\nimport {\n  AppResponse,\n  CodeInfo,\n  ContractInfo,\n  ContractInfoResponse,\n  DebugLog,\n  ExecuteTraceLog,\n  ReplyMsg,\n  ReplyTraceLog,\n  Snapshot,\n  TraceLog,\n} from '../../types';\nimport Contract from './contract';\nimport { buildAppResponse, buildContractAddress, wrapReplyResponse } from './wasm-util';\nimport {\n  BinaryKVIterStorage,\n  ContractResponse,\n  Env,\n  Event,\n  ReplyOn,\n  SubMsg,\n  WasmMsg,\n  compare,\n} from '@oraichain/cosmwasm-vm-js';\n\ntype WasmData = {\n  lastCodeId: number;\n  lastInstanceId: number;\n  codes: Record<number, CodeInfo>;\n  contracts: Record<string, ContractInfo>;\n  contractStorage: Record<string, Immutable.Map<unknown, unknown>>;\n};\n\nexport interface SmartQuery {\n  contract_addr: string;\n  msg: string; // Binary\n}\n\nexport interface RawQuery {\n  contract_addr: string;\n  key: string; // Binary\n}\n\nexport interface ContractInfoQuery {\n  contract_addr: string;\n}\n\nexport type WasmQuery = { smart: SmartQuery } | { raw: RawQuery } | { contract_info: ContractInfoQuery };\n\nexport class WasmModule {\n  public static checksumCache: Record<number, string> = {};\n  public readonly store: TransactionalLens<WasmData>;\n\n  // TODO: benchmark w/ many coexisting VMs\n  private contracts: Record<string, Contract> = {};\n\n  constructor(public readonly chain: CWSimulateApp) {\n    this.store = chain.store.db.lens<WasmData>('wasm').initialize({\n      lastCodeId: 0,\n      lastInstanceId: 0,\n      codes: {},\n      contracts: {},\n      contractStorage: {},\n    });\n  }\n\n  setContractStorage(contractAddress: string, value: Map<unknown, unknown>) {\n    this.store.tx(setter => {\n      setter('contractStorage', contractAddress)(value);\n      return Ok(undefined);\n    });\n  }\n\n  getContractStorage(contractAddress: string, storage?: Snapshot) {\n    return this.lens(storage).get('contractStorage', contractAddress);\n  }\n\n  setCodeInfo(codeId: number, codeInfo: CodeInfo) {\n    this.store.tx(setter => {\n      setter('codes', codeId)(codeInfo);\n      return Ok(undefined);\n    });\n  }\n\n  forEachCodeInfo(callback: (codeInfo: CodeInfo, codeId: number) => void, storage?: Snapshot) {\n    const { data } = this.lens(storage).lens('codes');\n    data.forEach((lens, codeId) => {\n      const codeInfo: CodeInfo = {\n        creator: lens.get('creator') as string,\n        wasmCode: lens.get('wasmCode') as Uint8Array,\n      };\n      callback(codeInfo, Number(codeId));\n    });\n  }\n\n  getCodeInfo(codeId: number, storage?: Snapshot) {\n    const lens = this.lens(storage).lens('codes', codeId);\n    if (!lens) return;\n\n    const codeInfo: CodeInfo = {\n      creator: lens.get('creator'),\n      wasmCode: lens.get('wasmCode'),\n    };\n    return codeInfo;\n  }\n\n  setContractInfo(contractAddress: string, contractInfo: ContractInfo) {\n    this.store.tx(setter => {\n      setter('contracts', contractAddress)(contractInfo);\n      return Ok(undefined);\n    });\n  }\n\n  getContractInfo(contractAddress: string, storage?: Snapshot) {\n    const lens = this.lens(storage).lens('contracts', contractAddress);\n    if (!lens?.data) return;\n    return lens.data.toObject() as any as ContractInfo;\n  }\n\n  /** Store a new CosmWasm smart contract bytecode */\n  storeCode(creator: string, wasmCode: Uint8Array) {\n    return this.chain.pushBlock(() => {\n      return this.store.tx(setter => {\n        let codeInfo: CodeInfo = {\n          creator,\n          wasmCode,\n        };\n\n        const codeId = this.lastCodeId + 1;\n        this.setCodeInfo(codeId, codeInfo);\n        setter('lastCodeId')(codeId);\n        return Ok(codeId);\n      });\n    });\n  }\n\n  /** Alias for `storeCode`, except it `.unwrap`s the result - kept for backwards compatibility */\n  create(creator: string, wasmCode: Uint8Array): number {\n    return this.storeCode(creator, wasmCode).unwrap();\n  }\n\n  /** Get the `Env` under which the next execution should run */\n  getExecutionEnv(contractAddress: string): Env {\n    return {\n      block: {\n        height: this.chain.height,\n        time: this.chain.time.toFixed(),\n        chain_id: this.chain.chainId,\n      },\n      contract: {\n        address: contractAddress,\n      },\n    };\n  }\n\n  getContract(address: string) {\n    if (!this.contracts[address]) {\n      this.contracts[address] = new Contract(this, address);\n    }\n    return this.contracts[address]!;\n  }\n\n  getContracts(): Contract[] {\n    return Object.values(this.contracts);\n  }\n\n  /** Register a new contract instance from codeId */\n  protected registerContractInstance(\n    sender: string,\n    codeId: number,\n    label = '',\n    admin: string | null = null\n  ): Result<string, string> {\n    return this.store.tx(setter => {\n      const contractAddressHash = buildContractAddress(codeId, this.lastInstanceId + 1);\n\n      const contractAddress = toBech32(this.chain.bech32Prefix, contractAddressHash);\n\n      const contractInfo = {\n        codeId,\n        creator: sender,\n        admin,\n        label,\n        created: this.chain.height,\n      };\n\n      this.setContractInfo(contractAddress, contractInfo);\n      this.setContractStorage(\n        contractAddress,\n        this.chain.kvIterStorageRegistry === BinaryKVIterStorage ? SortedMap(compare) : Map()\n      );\n\n      setter('lastInstanceId')(this.lastInstanceId + 1);\n      return Ok(contractAddress);\n    });\n  }\n\n  async instantiateContract(\n    sender: string,\n    funds: Coin[],\n    codeId: number,\n    instantiateMsg: any,\n    label: string,\n    admin: string | null = null,\n    traces: TraceLog[] = []\n  ): Promise<Result<AppResponse, string>> {\n    return await this.chain.pushBlock(async () => {\n      // first register the contract instance\n      const contractAddress = this.registerContractInstance(sender, codeId, label, admin).unwrap();\n      let logs = [] as DebugLog[];\n\n      const contract = await this.getContract(contractAddress).init();\n      const tracebase: Omit<ExecuteTraceLog, 'response' | 'result'> = {\n        [NEVER_IMMUTIFY]: true,\n        type: 'instantiate',\n        contractAddress,\n        msg: instantiateMsg,\n        info: { sender, funds },\n        logs,\n        env: contract.getExecutionEnv(),\n        storeSnapshot: this.store.db.data,\n      };\n\n      // create bank transfer\n      if (funds.length) {\n        const send = this.chain.bank.send(sender, contract.address, funds);\n        if (send.err) {\n          traces.push({\n            ...tracebase,\n            response: send,\n            result: send,\n          });\n          return send;\n        }\n      }\n\n      // then call instantiate\n      let response = contract.instantiate(sender, funds, instantiateMsg, logs);\n\n      if (response.err) {\n        traces.push({\n          ...tracebase,\n          response,\n          result: response,\n        });\n        return response;\n      }\n      let customEvent: Event = {\n        type: 'instantiate',\n        attributes: [\n          { key: '_contract_address', value: contractAddress },\n          { key: 'code_id', value: codeId.toString() },\n        ],\n      };\n\n      if (typeof response.val === 'string') {\n        throw new Error(response.val.toString());\n      }\n\n      let res = buildAppResponse(contractAddress, customEvent, response.val);\n\n      let subtraces: TraceLog[] = [];\n\n      let result = await this.handleContractResponse(contractAddress, response.val.messages, res, subtraces);\n\n      traces.push({\n        ...tracebase,\n        response,\n        result,\n        traces: subtraces,\n        storeSnapshot: this.store.db.data,\n      });\n\n      return result;\n    });\n  }\n\n  /** Call migrate on the CW SC */\n  async migrateContract(\n    sender: string,\n    newCodeId: number,\n    contractAddress: string,\n    migrateMsg: any,\n    traces: TraceLog[] = []\n  ): Promise<Result<AppResponse, string>> {\n    return await this.chain.pushBlock(async () => {\n      const contract = this.getContract(contractAddress);\n      const info = this.getContractInfo(contractAddress);\n      if (info === undefined) {\n        throw new Error(`Contract ${contractAddress} not found`);\n      }\n      info.codeId = newCodeId;\n      // update contract info\n      this.setContractInfo(contractAddress, info);\n\n      // rebuild wasmCode\n      const { wasmCode } = this.getCodeInfo(info.codeId);\n      await contract.vm.build(wasmCode, WasmModule.checksumCache[info.codeId]);\n\n      const logs: DebugLog[] = [];\n      const tracebase: Omit<ExecuteTraceLog, 'response' | 'result'> = {\n        [NEVER_IMMUTIFY]: true,\n        type: 'migrate',\n        contractAddress,\n        msg: migrateMsg,\n        info: { sender, funds: [] },\n        logs,\n        env: contract.getExecutionEnv(),\n        storeSnapshot: this.store.db.data,\n      };\n\n      // then call instantiate\n      let response = contract.migrate(migrateMsg, logs);\n\n      if (response.err) {\n        traces.push({\n          ...tracebase,\n          response,\n          result: response,\n        });\n        return response;\n      }\n      let customEvent: Event = {\n        type: 'migrate',\n        attributes: [{ key: '_contract_address', value: contractAddress }],\n      };\n\n      if (typeof response.val === 'string') {\n        throw new Error(response.val.toString());\n      }\n\n      let res = buildAppResponse(contractAddress, customEvent, response.val);\n\n      let subtraces: TraceLog[] = [];\n\n      let result = await this.handleContractResponse(contractAddress, response.val.messages, res, subtraces);\n\n      traces.push({\n        ...tracebase,\n        response,\n        result,\n        traces: subtraces,\n        storeSnapshot: this.store.db.data,\n      });\n\n      return result;\n    });\n  }\n\n  /** Call execute on the CW SC */\n  async executeContract(\n    sender: string,\n    funds: Coin[],\n    contractAddress: string,\n    executeMsg: any,\n    traces: TraceLog[] = []\n  ): Promise<Result<AppResponse, string>> {\n    return await this.chain.pushBlock(async () => {\n      const contract = await this.getContract(contractAddress).init();\n      const logs: DebugLog[] = [];\n\n      const tracebase: Omit<ExecuteTraceLog, 'response' | 'result'> = {\n        [NEVER_IMMUTIFY]: true,\n        type: 'execute',\n        contractAddress,\n        msg: executeMsg,\n        logs,\n        env: contract.getExecutionEnv(),\n        info: { sender, funds },\n        storeSnapshot: this.store.db.data,\n      };\n\n      if (funds.length) {\n        const send = this.chain.bank.send(sender, contractAddress, funds);\n        if (send.err) {\n          traces.push({\n            ...tracebase,\n            response: send,\n            result: send,\n          });\n          return send;\n        }\n      }\n\n      const response = contract.execute(sender, funds, executeMsg, logs);\n\n      if (response.err) {\n        traces.push({\n          ...tracebase,\n          response,\n          result: response,\n        });\n        return response;\n      }\n      let customEvent = {\n        type: 'execute',\n        attributes: [\n          {\n            key: '_contract_address',\n            value: contractAddress,\n          },\n        ],\n      };\n\n      if (typeof response.val === 'string') {\n        throw new Error(response.val.toString());\n      }\n\n      let res = buildAppResponse(contractAddress, customEvent, response.val);\n\n      let subtraces: TraceLog[] = [];\n      let result = await this.handleContractResponse(contractAddress, response.val.messages, res, subtraces);\n\n      traces.push({\n        ...tracebase,\n        response,\n        result,\n        traces: subtraces,\n        storeSnapshot: this.store.db.data,\n      });\n\n      return result;\n    });\n  }\n\n  // like AppResponse, just extend attribute and process subMsg instead of return Result\n  public async handleIbcResponse(\n    contractAddress: string,\n    res: ContractResponse,\n    traces: TraceLog[] = []\n  ): Promise<ContractResponse> {\n    if (res?.messages) {\n      await this.handleContractResponse(contractAddress, res.messages, res, traces);\n    }\n    return res;\n  }\n\n  /** Process contract response & execute (sub)messages */\n  protected async handleContractResponse(\n    contractAddress: string,\n    messages: ContractResponse['messages'],\n    res: AppResponse,\n    traces: TraceLog[] = []\n  ): Promise<Result<AppResponse, string>> {\n    for (const message of messages) {\n      const subres = await this.handleSubmsg(contractAddress, message, traces);\n      if (subres.err) {\n        return subres;\n      }\n      if (typeof subres.val === 'string') {\n        throw new Error(subres.val.toString());\n      }\n\n      res.events = [...res.events, ...subres.val.events];\n\n      if (subres.val.data !== null) {\n        res.data = subres.val.data;\n      }\n    }\n\n    return Ok({ events: res.events, data: res.data });\n  }\n\n  /** Handle a submessage returned in the response of a contract execution */\n  protected async handleSubmsg(\n    contractAddress: string,\n    message: SubMsg,\n    traces: TraceLog[] = []\n  ): Promise<Result<AppResponse, string>> {\n    return this.store.tx(async () => {\n      let { id, msg, gas_limit, reply_on } = message;\n      let r = await this.chain.handleMsg(contractAddress, msg, traces);\n\n      if (r.ok) {\n        // submessage success\n        let { events, data } = r.val;\n\n        if (reply_on === ReplyOn.Success || reply_on === ReplyOn.Always) {\n          // submessage success, call reply\n          let replyMsg: ReplyMsg = {\n            id,\n            result: {\n              ok: {\n                events,\n                // wrap data reply\n                data: wrapReplyResponse(r.val).data,\n              },\n            },\n          };\n\n          let replyRes = await this.reply(contractAddress, replyMsg, traces);\n          if (replyRes.err) {\n            // submessage success, call reply, reply failed\n            return replyRes;\n          }\n          if (typeof replyRes.val === 'string') {\n            throw new Error(replyRes.val.toString());\n          }\n\n          // submessage success, call reply, reply success\n          if (replyRes.val.data !== null) {\n            data = replyRes.val.data;\n          }\n          events = [...events, ...replyRes.val.events];\n        } else {\n          // submessage success, don't call reply\n          data = null;\n        }\n\n        return Ok({ events, data });\n      }\n\n      // if panicked then throw Error\n      const errMsg = r.val.toString();\n      if (errMsg.startsWith('abort: panicked')) {\n        throw new Error(errMsg);\n      }\n\n      // submessage failed\n      if (reply_on === ReplyOn.Error || reply_on === ReplyOn.Always) {\n        // submessage failed, call reply\n        let replyMsg: ReplyMsg = {\n          id,\n          result: {\n            error: errMsg,\n          },\n        };\n\n        let replyRes = await this.reply(contractAddress, replyMsg, traces);\n        if (replyRes.err) {\n          // submessage failed, call reply, reply failed\n          return replyRes;\n        }\n        // submessage failed, call reply, reply success\n        let { events, data } = replyRes.val as AppResponse;\n        return Ok({ events, data });\n      }\n      // submessage failed, don't call reply (equivalent to normal message)\n      return r;\n    });\n  }\n\n  protected async reply(\n    contractAddress: string,\n    replyMsg: ReplyMsg,\n    traces: TraceLog[] = []\n  ): Promise<Result<AppResponse, string>> {\n    const logs: DebugLog[] = [];\n    const contract = this.getContract(contractAddress);\n    const response = contract.reply(replyMsg, logs);\n\n    const tracebase: Omit<ReplyTraceLog, 'response' | 'result'> = {\n      [NEVER_IMMUTIFY]: true,\n      type: 'reply',\n      contractAddress,\n      msg: replyMsg,\n      env: contract.getExecutionEnv(),\n      logs,\n      storeSnapshot: this.store.db.data,\n    };\n\n    if (response.err) {\n      traces.push({\n        ...tracebase,\n        response,\n        result: response,\n      });\n      return response;\n    }\n    const customEvent = {\n      type: 'reply',\n      attributes: [\n        {\n          key: '_contract_address',\n          value: contractAddress,\n        },\n        {\n          key: 'mode',\n          value: 'ok' in replyMsg.result ? 'handle_success' : 'handle_failure',\n        },\n      ],\n    };\n\n    if (response.err || typeof response.val === 'string') {\n      throw new Error(response.val.toString());\n    }\n\n    let res = buildAppResponse(contractAddress, customEvent, response.val);\n\n    let subtraces: TraceLog[] = [];\n    let result = await this.handleContractResponse(contractAddress, response.val.messages, res, subtraces);\n\n    traces.push({\n      ...tracebase,\n      response,\n      result,\n      storeSnapshot: this.store.db.data,\n    });\n\n    return result;\n  }\n\n  query(contractAddress: string, queryMsg: any): Result<any, string> {\n    return this.getContract(contractAddress).query(queryMsg);\n  }\n\n  queryTrace(trace: TraceLog, queryMsg: any): Result<any, string> {\n    let { contractAddress, storeSnapshot } = trace;\n    return this.getContract(contractAddress).query(queryMsg, storeSnapshot as Map<string, string>);\n  }\n\n  async handleMsg(sender: string, msg: WasmMsg, traces: TraceLog[] = []): Promise<Result<AppResponse, string>> {\n    return this.store.tx(async () => {\n      let wasm = msg;\n      if ('execute' in wasm) {\n        let { contract_addr, funds, msg } = wasm.execute;\n        return await this.executeContract(sender, funds, contract_addr, fromBinary(msg), traces);\n      }\n      if ('instantiate' in wasm) {\n        let { code_id, funds, msg, label, admin } = wasm.instantiate;\n        return await this.instantiateContract(sender, funds, code_id, fromBinary(msg), label, admin, traces);\n      }\n      if ('migrate' in wasm) {\n        let { contract_addr, new_code_id, msg } = wasm.migrate;\n        return await this.migrateContract(sender, new_code_id, contract_addr, fromBinary(msg), traces);\n      }\n      throw new Error('Unknown wasm message');\n    });\n  }\n\n  handleQuery(query: WasmQuery): any {\n    if ('smart' in query) {\n      const { contract_addr, msg } = query.smart;\n      const result = this.query(contract_addr, fromBinary(msg));\n      // call query from other contract\n      if (result.ok) {\n        return result.val;\n      }\n      // wrap Err message for contract query result\n      const errMsg: string = result.val.toString();\n\n      // panic divide by zero should not process in query but return original value\n      if (errMsg.startsWith('Divide by zero:')) {\n        return '0';\n      }\n\n      // TODO: differentiate error between js and contract\n\n      // contract error\n      return Err(errMsg);\n\n      // // normal error\n      // throw new Error(errMsg);\n    }\n    if ('raw' in query) {\n      const { contract_addr, key } = query.raw;\n\n      const storage = this.getContractStorage(contract_addr);\n      if (!storage) {\n        throw new Error(`Contract ${contract_addr} not found`);\n      }\n\n      // check if storage is BinaryKVIterStorage then key must be Uint8Array\n\n      const value =\n        this.chain.kvIterStorageRegistry === BinaryKVIterStorage\n          ? // @ts-ignore\n            toBase64(storage.get(fromBase64(key)))\n          : // @ts-ignore\n            storage.get(key);\n\n      if (value === undefined) {\n        throw new Error(`Key ${key} not found`);\n      } else {\n        return value;\n      }\n    }\n    if ('contract_info' in query) {\n      const { contract_addr } = query.contract_info;\n      const info = this.getContractInfo(contract_addr);\n      if (info === undefined) {\n        throw new Error(`Contract ${contract_addr} not found`);\n      }\n      const { codeId: code_id, creator, admin } = info;\n      const resp: ContractInfoResponse = {\n        code_id,\n        creator,\n        admin,\n        ibc_port: this.chain.ibc.getContractIbcPort(contract_addr),\n        // TODO: VM lifetime mgmt\n        // currently all VMs are always loaded ie pinned\n        pinned: true,\n      };\n\n      return resp;\n    }\n    throw new Error('Unknown wasm query');\n  }\n\n  private lens(storage?: Snapshot) {\n    return storage ? lensFromSnapshot(storage) : this.store;\n  }\n\n  protected pushTrace(traces: TraceLog[], details: Omit<TraceLog, typeof NEVER_IMMUTIFY | 'env'>) {\n    //@ts-ignore\n    traces.push({\n      [NEVER_IMMUTIFY]: true,\n      ...details,\n      env: this.getExecutionEnv(details.contractAddress),\n    });\n  }\n\n  get lastCodeId() {\n    return this.store.get('lastCodeId');\n  }\n  get lastInstanceId() {\n    return this.store.get('lastInstanceId');\n  }\n}\n\nexport function lensFromSnapshot(snapshot: Snapshot) {\n  return new Transactional(snapshot).lens<WasmData>('wasm');\n}\n","import { Sha256 } from '@cosmjs/crypto';\nimport protobuf from 'protobufjs';\nimport { ContractResponse, Event, writeUInt32BE } from '@oraichain/cosmwasm-vm-js';\nimport { toBase64 } from '@cosmjs/encoding';\nimport { AppResponse } from '../../types';\n\nconst protobufRoot = protobuf.Root.fromJSON({\n  nested: {\n    MsgInstantiateContractResponse: {\n      fields: {\n        address: {\n          type: 'string',\n          id: 1,\n        },\n        data: {\n          type: 'bytes',\n          id: 2,\n        },\n      },\n    },\n  },\n});\n\nexport function wrapReplyResponse(res: AppResponse): AppResponse {\n  const MsgInstantiateContractResponse = protobufRoot.lookupType('MsgInstantiateContractResponse');\n\n  const payload = {\n    data: res.data,\n    address: null,\n  };\n\n  for (const event of res.events) {\n    const address = event.attributes.find(attr => attr.key === '_contract_address')?.value;\n    if (address) {\n      payload.address = address;\n      break;\n    }\n  }\n\n  const message = MsgInstantiateContractResponse.create(payload); //;\n  return {\n    events: res.events,\n    data: toBase64(MsgInstantiateContractResponse.encode(message).finish()),\n  };\n}\n\nexport function buildContractAddress(codeId: number, instanceId: number): Uint8Array {\n  const payload = Buffer.alloc(21); // wasm0 + contractId = 5 + 16, and initialized to 0 by default\n  payload.write('wasm');\n  // append code id\n  writeUInt32BE(payload, codeId, 9);\n  writeUInt32BE(payload, instanceId, 17);\n\n  let hasher = new Sha256();\n  hasher.update(Buffer.from('module', 'utf-8'));\n  let th = hasher.digest();\n  hasher = new Sha256(th);\n  hasher.update(payload);\n  let hash = hasher.digest();\n  return hash.slice(0, 20);\n}\n\nexport function buildAppResponse(contract: string, customEvent: Event, response: ContractResponse): AppResponse {\n  const appEvents: Event[] = [];\n  // add custom event\n  appEvents.push(customEvent);\n\n  // add contract attributes under `wasm` event type\n  if (response.attributes.length > 0) {\n    appEvents.push({\n      type: 'wasm',\n      attributes: [\n        {\n          key: '_contract_address',\n          value: contract,\n        },\n        ...response.attributes,\n      ],\n    });\n  }\n\n  // add events and prefix with `wasm-`\n  for (const event of response.events) {\n    appEvents.push({\n      type: `wasm-${event.type}`,\n      attributes: [{ key: '_contract_address', value: contract }, ...event.attributes],\n    });\n  }\n\n  return {\n    events: appEvents,\n    data: response.data,\n  };\n}\n","import Serde, { SERDE, StandardProtocolMap } from '@kiruse/serde';\nimport { Reference } from '@kiruse/serde/dist/types';\nimport { List, Map } from '@oraichain/immutable';\nimport { Ok } from 'ts-results';\nimport { CWSimulateApp } from './CWSimulateApp';\n\ntype Protocols = StandardProtocolMap & {\n  'immutable-list': List<any>;\n  'immutable-map': Map<any, any>;\n  'cw-simulate-app': CWSimulateApp;\n};\n\nexport const serde = Serde<Protocols>()\n  .standard()\n  .setSimple(\n    'immutable-list',\n    (list: List<any>, data) => {\n      return {\n        data: data(list.toArray()),\n        // ownerID is a unique object that should not even appear on\n        // other Immutable data structures. When present, it signifies\n        // that the Immutable should be mutated in-place rather than\n        // creating copies of its data.\n        mutable: !!(list as any).__ownerID,\n      };\n    },\n    ({ data, mutable }, deref) => {\n      if (!data.length) return List();\n      const list = List().asMutable();\n      Reference.all(deref, data, values => {\n        list.push(...values);\n        !mutable && list.asImmutable();\n      });\n      return list;\n    }\n  )\n  .setSimple(\n    'immutable-map',\n    (map: Map<any, any>, data) => {\n      return {\n        data: data(map.toObject()),\n        // same as with List above\n        mutable: !!(map as any).__ownerID,\n      };\n    },\n    ({ data, mutable }, deref) => {\n      const map = Map().asMutable();\n      const keys = Object.keys(data);\n      if (!keys.length) return Map();\n      Reference.all(\n        deref,\n        keys.map(k => data[k]),\n        values => {\n          values.forEach((value, i) => {\n            const key = keys[i];\n            map.set(key, value);\n          });\n          !mutable && map.asImmutable();\n        }\n      );\n      return map;\n    }\n  )\n  .setSimple(\n    'cw-simulate-app',\n    (app: CWSimulateApp) => ({\n      chainId: app.chainId,\n      bech32Prefix: app.bech32Prefix,\n      store: app.store.db.data,\n    }),\n    ({ chainId, bech32Prefix, store }, deref): CWSimulateApp => {\n      // for sorted type, metering, need to update when restored succesfully\n      const app = new CWSimulateApp({\n        chainId,\n        bech32Prefix,\n      });\n      Reference.all(deref, [store], ([map]) => {\n        app.store.db.tx(update => {\n          update(() => map);\n          return Ok(undefined);\n        });\n      });\n      return app;\n    }\n  );\n\nexport const save = (app: CWSimulateApp) => serde.serializeAs('cw-simulate-app', app).compress().buffer;\n\nexport const load = async (bytes: Uint8Array) => {\n  const app = serde.deserializeAs('cw-simulate-app', bytes);\n  const contracts = [...app.wasm.store.get('contracts').keys()];\n  await Promise.all(contracts.map(address => app.wasm.getContract(address).init()));\n  return app;\n};\n\n// Inject SERDE\nMap.prototype[SERDE] = 'immutable-map';\nList.prototype[SERDE] = 'immutable-list';\n","export * from './transactional';\n","import { isCollection, isList, isMap, List, Map } from '@oraichain/immutable';\nimport { Err, Ok, Result } from 'ts-results';\nimport { fromRustResult, isArrayLike, isRustResult, isTSResult } from '../util';\n\n// NEVER_IMMUTIFY is a string because that's easily serializable with different algorithms - symbols are not\nexport type NeverImmutify = typeof NEVER_IMMUTIFY;\nexport const NEVER_IMMUTIFY = '__NEVER_IMMUTIFY__';\n\ntype Primitive = boolean | number | bigint | string | null | undefined | symbol;\ntype NoImmutify = Primitive | ArrayBuffer | ArrayBufferView | { [NEVER_IMMUTIFY]: any };\n\ntype Prefix<P, T extends any[]> = [P, ...T];\ntype First<T extends any[]> = T extends Prefix<infer F, any[]> ? F : never;\ntype Shift<T extends any[]> = T extends Prefix<any, infer R> ? R : [];\n\n// god type\ntype Lens<T, P extends PropertyKey[]> = P extends Prefix<any, any[]>\n  ? First<P> extends keyof T\n    ? Shift<P> extends Prefix<any, any[]>\n      ? Lens<T[First<P>], Shift<P>>\n      : T[First<P>]\n    : never\n  : T;\n\ntype Immutify<T> = T extends NoImmutify\n  ? T\n  : T extends ArrayLike<infer E>\n  ? List<Immutify<E>>\n  : T extends Record<infer K, infer V>\n  ? Map<K, Immutify<V>>\n  : T;\n\ntype TxUpdater = (set: TxSetter) => void;\ntype TxSetter = (current: Map<unknown, unknown>) => Map<unknown, unknown>;\ntype LensSetter<T> = <P extends PropertyKey[]>(...path: P) => (value: Lens<T, P> | Immutify<Lens<T, P>>) => void;\ntype LensDeleter = <P extends PropertyKey[]>(...path: P) => void;\n\n/** Transactional database underlying multi-module chain storage. */\nexport class Transactional {\n  constructor(private _data = Map()) {}\n\n  lens<M extends object>(...path: PropertyKey[]) {\n    return new TransactionalLens<M>(this, path.map(stringify));\n  }\n\n  tx<R extends Result<any, any>>(cb: (update: TxUpdater) => Promise<R>): Promise<R>;\n  tx<R extends Result<any, any>>(cb: (update: TxUpdater) => R): R;\n  tx<R extends Result<any, any>>(cb: (update: TxUpdater) => R | Promise<R>): R | Promise<R> {\n    let valid = true;\n    const snapshot = this._data;\n    const updater: TxUpdater = setter => {\n      if (!valid) throw new Error('Attempted to set data outside tx');\n      this._data = setter(this._data);\n    };\n\n    try {\n      const result = cb(updater);\n      if ('then' in result) {\n        return result\n          .then(r => {\n            if (r.err) {\n              this._data = snapshot;\n            }\n            return r;\n          })\n          .catch(reason => {\n            this._data = snapshot;\n            throw reason;\n          });\n      } else {\n        if (result.err) {\n          this._data = snapshot;\n        }\n        return result;\n      }\n    } catch (ex) {\n      this._data = snapshot;\n      throw ex;\n    } finally {\n      valid = false;\n    }\n  }\n\n  get data() {\n    return this._data;\n  }\n}\n\nexport class TransactionalLens<M extends object> {\n  constructor(public readonly db: Transactional, public readonly prefix: string[]) {}\n\n  initialize(data: M) {\n    this.db\n      .tx(update => {\n        const coll = toImmutable(data);\n        if (!isCollection(coll)) throw new Error('Not an Immutable.Map');\n        update(curr => curr.setIn([...this.prefix], coll));\n        return Ok(undefined);\n      })\n      .unwrap();\n    return this;\n  }\n\n  get<P extends PropertyKey[]>(...path: P): Immutify<Lens<M, P>> {\n    return this.db.data.getIn([...this.prefix, ...path.map(stringify)]) as any;\n  }\n\n  getObject<P extends PropertyKey[]>(...path: P): Lens<M, P> {\n    return fromImmutable(this.get(...path));\n  }\n\n  tx<R extends Result<any, any>>(cb: (setter: LensSetter<M>, deleter: LensDeleter) => Promise<R>): Promise<R>;\n  tx<R extends Result<any, any>>(cb: (setter: LensSetter<M>, deleter: LensDeleter) => R): R;\n  tx<R extends Result<any, any>>(cb: (setter: LensSetter<M>, deleter: LensDeleter) => R | Promise<R>): R | Promise<R> {\n    //@ts-ignore\n    return this.db.tx(update => {\n      const setter: LensSetter<M> =\n        <P extends PropertyKey[]>(...path: P) =>\n        (value: Lens<M, P> | Immutify<Lens<M, P>>) => {\n          update(curr => curr.setIn([...this.prefix, ...path.map(stringify)], toImmutable(value)));\n        };\n      const deleter: LensDeleter = <P extends PropertyKey[]>(...path: P) => {\n        update(curr => curr.deleteIn([...this.prefix, ...path.map(stringify)]));\n      };\n      return cb(setter, deleter);\n    });\n  }\n\n  lens<P extends PropertyKey[]>(...path: P): TransactionalLens<Lens<M, P>> {\n    return new TransactionalLens<Lens<M, P>>(this.db, [...this.prefix, ...path.map(stringify)]);\n  }\n\n  get data() {\n    return this.db.data.getIn([...this.prefix]) as Immutify<M>;\n  }\n}\n\nexport function toImmutable(value: any): any {\n  // passthru Immutable collections\n  if (isCollection(value)) return value;\n\n  // don't touch ArrayBuffers & ArrayBufferViews - freeze them\n  if (ArrayBuffer.isView(value)) {\n    Object.freeze(value.buffer);\n    return value;\n  }\n  if (value instanceof ArrayBuffer) {\n    Object.freeze(value);\n    return value;\n  }\n\n  // recurse into arrays & objects, converting them to lists & maps\n  // skip primitives & objects that don't want to be touched\n  if (value && typeof value === 'object' && !(NEVER_IMMUTIFY in value)) {\n    if (isArrayLike(value)) {\n      return List(value.map(item => toImmutable(item)));\n    } else {\n      return Map(Object.entries(value).map(([key, value]) => [key, toImmutable(value)]));\n    }\n  }\n\n  return value;\n}\n\nexport function fromImmutable(value: any): any {\n  // reverse Immutable maps & lists\n  if (isMap(value)) {\n    return fromImmutable(value.toObject());\n  }\n  if (isList(value)) {\n    return fromImmutable(value.toArray());\n  }\n\n  // passthru ArrayBuffers & ArrayBufferViews\n  if (value instanceof ArrayBuffer || ArrayBuffer.isView(value)) return value;\n\n  // revert objects & arrays\n  // but: passthru objects w/ NEVER_IMMUTIFY\n  if (value && typeof value === 'object' && !(NEVER_IMMUTIFY in value)) {\n    if (typeof value.length === 'number' && 0 in value && value.length - 1 in value) {\n      for (let i = 0; i < value.length; ++i) {\n        value[i] = fromImmutable(value[i]);\n      }\n    } else {\n      for (const prop in value) {\n        value[prop] = fromImmutable(value[prop]);\n      }\n    }\n    return value;\n  }\n\n  return value;\n}\n\nconst stringify = (v: any) => v + '';\n","import Immutable from '@oraichain/immutable';\nimport { Result } from 'ts-results';\nimport type { NEVER_IMMUTIFY } from './store/transactional';\nimport {\n  Attribute,\n  Binary,\n  ContractResponse,\n  Env,\n  IbcTimeout,\n  MessageInfo,\n  SubMsg,\n  Event,\n} from '@oraichain/cosmwasm-vm-js';\n\nexport interface AppResponse {\n  events: Event[];\n  data: string | null;\n}\n\nexport type RustResult<T> = { ok: T } | { error: string };\n\nexport type ReplyMsg = {\n  id: number;\n  result: RustResult<{\n    events: Event[];\n    data: string | null;\n  }>;\n};\n\nexport interface CodeInfo {\n  creator: string;\n  wasmCode: Uint8Array;\n}\n\nexport interface ContractInfo {\n  codeId: number;\n  creator: string;\n  admin: string | null;\n  label: string;\n  created: number; // chain height\n}\n\nexport interface ContractInfoResponse {\n  code_id: number;\n  creator: string;\n  admin: string | null;\n  pinned: boolean;\n  ibc_port: string | null;\n}\n\nexport type DebugLog = PrintDebugLog | CallDebugLog;\n\nexport interface PrintDebugLog {\n  type: 'print';\n  message: string;\n}\n\ntype Bytes = string;\n\ntype NamedArg<T extends any = any> = { [name: string]: T };\n\ntype APIFn<CallArgs extends NamedArg, ReturnType = undefined> = ReturnType extends undefined\n  ? {\n      args: CallArgs;\n    }\n  : {\n      args: CallArgs;\n      result: ReturnType;\n    };\n\ninterface CosmWasmAPI {\n  db_read: APIFn<{ key: Bytes }, Bytes>;\n  db_write: APIFn<{ key: Bytes; value: Bytes }>;\n  db_remove: APIFn<{ key: Bytes }>;\n  db_scan: APIFn<{ start: Bytes; end: Bytes; order: number }, Bytes>;\n  db_next: APIFn<{ iterator_id: Bytes }, Bytes>;\n  addr_humanize: APIFn<{ source: Bytes }, Bytes>;\n  addr_canonicalize: APIFn<{ source: Bytes; destination: Bytes }, Bytes>;\n  addr_validate: APIFn<{ source: Bytes }, Bytes>;\n  secp256k1_verify: APIFn<{ hash: Bytes; signature: Bytes; pubkey: Bytes }, number>;\n  secp256k1_recover_pubkey: APIFn<{ msgHash: Bytes; signature: Bytes; recover_param: number }, Bytes>;\n  abort: APIFn<{ message: string }>;\n  debug: APIFn<{ message: string }>;\n  ed25519_verify: APIFn<{ message: Bytes; signature: Bytes; pubkey: Bytes }, number>;\n  ed25519_batch_verify: APIFn<{ messages_ptr: Bytes; signatures_ptr: Bytes; pubkeys_ptr: Bytes }, number>;\n  query_chain: APIFn<{ request: Bytes }, Bytes>;\n}\n\ntype Unionize<T> = T extends { [key in keyof T]: infer ValueType } ? ValueType : never;\n\ntype CallDebugLog<T extends keyof CosmWasmAPI = keyof CosmWasmAPI> = {\n  type: 'call';\n} & Unionize<{\n  [K in T]: { fn: K } & CosmWasmAPI[K];\n}>;\n\nexport type Snapshot = Immutable.Map<unknown, unknown>;\n\ninterface TraceLogCommon {\n  [NEVER_IMMUTIFY]: true;\n  type: string;\n  contractAddress: string;\n  env: Env;\n  msg: any;\n  response: Result<ContractResponse, string>;\n  logs: DebugLog[];\n  traces?: TraceLog[];\n  storeSnapshot: Snapshot;\n  result: Result<AppResponse, string>;\n}\n\nexport type ExecuteTraceLog = TraceLogCommon & {\n  type: 'execute' | 'instantiate' | 'migrate';\n  info: MessageInfo;\n};\n\nexport type ReplyTraceLog = TraceLogCommon & {\n  type: 'reply';\n  msg: ReplyMsg;\n};\n\nexport type TraceLog = ExecuteTraceLog | ReplyTraceLog;\n\nexport interface IbcEndpoint {\n  port_id: string;\n  channel_id: string;\n}\n\nexport interface IbcChannel {\n  endpoint: IbcEndpoint;\n  counterparty_endpoint: IbcEndpoint;\n  order: IbcOrder;\n  version: string;\n  connection_id: string;\n}\n\nexport enum IbcOrder {\n  Unordered = 'ORDER_UNORDERED',\n  Ordered = 'ORDER_ORDERED',\n}\n\nexport interface IbcAcknowledgement {\n  data: Binary;\n}\n\nexport interface IbcPacket {\n  /// The raw data sent from the other side in the packet\n  data: Binary;\n  /// identifies the channel and port on the sending chain.\n  src: IbcEndpoint;\n  /// identifies the channel and port on the receiving chain.\n  dest: IbcEndpoint;\n  /// The sequence number of the packet on the given channel\n  sequence: number;\n  timeout: IbcTimeout;\n}\n\nexport interface IbcPacketAckMsg {\n  acknowledgement: IbcAcknowledgement;\n  original_packet: IbcPacket;\n  relayer?: string;\n}\n\nexport interface IbcPacketReceiveMsg {\n  packet: IbcPacket;\n  relayer?: string;\n}\n\nexport interface IbcPacketTimeoutMsg {\n  packet: IbcPacket;\n  relayer?: string;\n}\n\nexport type IbcChannelOpenMsg =\n  | { open_init: { channel: IbcChannel } }\n  | {\n      open_try: {\n        channel: IbcChannel;\n        counterparty_version: string;\n      };\n    };\n\nexport type IbcChannelCloseMsg =\n  | { close_init: { channel: IbcChannel } }\n  | {\n      close_confirm: {\n        channel: IbcChannel;\n      };\n    };\n\nexport type IbcChannelConnectMsg =\n  | {\n      open_ack: {\n        channel: IbcChannel;\n        counterparty_version: string;\n      };\n    }\n  | {\n      open_confirm: { channel: IbcChannel };\n    };\n\nexport interface IbcChannelOpenResponse {\n  version: string;\n}\n\nexport interface IbcBasicResponse {\n  messages: SubMsg[];\n  attributes: Attribute[];\n  events: Event[];\n}\n\nexport interface IbcReceiveResponse {\n  acknowledgement: Binary;\n  messages: SubMsg[];\n  attributes: Attribute[];\n  events: Event[];\n}\n","import { Err, Ok, Result } from 'ts-results';\nimport { RustResult, DebugLog } from './types';\nimport { sha256 } from '@cosmjs/crypto';\nimport { toHex } from '@cosmjs/encoding';\n\nexport const isArrayLike = (value: any): value is any[] =>\n  typeof value === 'object' && typeof value.length === 'number';\n\nexport function fromRustResult<T>(res: RustResult<T>): Result<T, string>;\nexport function fromRustResult<T>(res: any): Result<T, string>;\nexport function fromRustResult<T>(res: any): Result<T, string> {\n  if ('ok' in res) {\n    return Ok(res.ok);\n  } else if (typeof res.error === 'string') {\n    return Err(res.error);\n  } else throw new Error('Invalid RustResult type');\n}\nexport function toRustResult<T>(res: Result<T, string>): RustResult<T> {\n  if (res.ok) {\n    return { ok: res.val };\n  } else {\n    return { error: res.val as string };\n  }\n}\n\nexport const isRustResult = <T = unknown>(value: any): value is RustResult<T> => 'ok' in value || 'err' in value;\nexport const isTSResult = <T = unknown, E = string>(value: any): value is Result<T, E> =>\n  typeof value.ok === 'boolean' && typeof value.err === 'boolean' && 'val' in value;\n\nexport const getTransactionHash = (height: number, data: any, encoding?: BufferEncoding) => {\n  const buf = Buffer.from(JSON.stringify({ data, height }), encoding);\n  return toHex(sha256(buf));\n};\n\n// debug debug print\nexport const printDebug = (log: DebugLog) => {\n  if (log.type === 'print') {\n    console.log(log.message);\n  }\n};\n","module.exports = require(\"@cosmjs/cosmwasm-stargate\");","module.exports = require(\"@cosmjs/crypto\");","module.exports = require(\"@cosmjs/encoding\");","module.exports = require(\"@kiruse/serde\");","module.exports = require(\"@kiruse/serde/dist/types\");","module.exports = require(\"@oraichain/cosmwasm-vm-js\");","module.exports = require(\"@oraichain/immutable\");","module.exports = require(\"eventemitter3\");","module.exports = require(\"protobufjs\");","module.exports = require(\"ts-results\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"names":["DefaultAppResponse","Ok","events","data","CWSimulateApp","SERDE","chainId","bech32Prefix","backendApi","debug","env","handleCustomMsg","store","kvIterStorageRegistry","wasm","bank","ibc","querier","constructor","options","this","BasicBackendApi","metering","Environment","gasLimit","BinaryKVIterStorage","printDebug","Transactional","SortedMap","compare","Map","lens","initialize","height","time","Date","now","WasmModule","BankModule","IbcModule","Querier","gasUsed","async","sender","msg","traces","handleMsg","Err","JSON","stringify","pushBlock","callback","tx","setter","current","get","QuerierBase","app","super","handleQuery","query","Error","SimulateCosmWasmClient","SigningCosmWasmClient","static","bytes","load","Uint8Array","from","appOrOptions","toBytes","save","address","info","setContractInfo","setContractStorage","isMap","getContract","init","getChainId","Promise","resolve","getHeight","getAccount","searchAddress","pubkey","accountNumber","sequence","getSequence","_address","getBlock","id","header","version","block","toString","txs","getBalance","searchDenom","coin","find","denom","amount","getCodes","codes","forEachCodeInfo","codeInfo","codeId","push","creator","checksum","checksumCache","getCodeDetails","getCodeInfo","codeDetails","wasmCode","contract","getContractInfo","admin","label","ibcPortId","undefined","sendTokens","senderAddress","recipientAddress","_fee","_memo","res","send","txIndex","code","ok","transactionHash","getTransactionHash","rawLog","val","gasWanted","msgResponses","upload","toHex","sha256","create","originalSize","length","compressedSize","logs","contractGasUsed","result","instantiateContract","funds","err","contractAddress","attributes","value","instructions","results","all","map","executeContract","fee","memo","executeMultiple","migrateMsg","migrateContract","key","raw","contract_addr","toBinary","fromBase64","queryMsg","reject","BufferStream","filePath","fd","sizeBuf","append","existsSync","openSync","Buffer","allocUnsafe","readSync","alloc","writeFileSync","increaseSize","i","size","readUInt32BE","close","closeSync","write","entries","n","k","v","outputBuffer","ind","set","writeSync","appendFileSync","BufferIter","buf","bufInd","reset","next","done","keyLength","subarray","valueLength","BufferCollection","toNumber","prototype","lcd","downloadPath","nextKey","bufStream","join","writeCallback","endCallback","startAfter","limit","url","URL","searchParams","console","log","models","pagination","fetch","signal","AbortSignal","timeout","then","json","next_key","ex","r","setTimeout","downloadState","chunks","contractFile","contract_info","code_id","loadStateData","buffer","readFileSync","rawPack","client","loadContract","created","SortedSet","CWSimulateVMInstance","VMInstance","debugFn","backend","processLog","do_db_read","type","fn","args","str","do_db_write","do_db_remove","do_db_scan","start","end","order","do_db_next","iterator_id","do_addr_humanize","source","destination","do_addr_canonicalize","do_addr_validate","do_secp256k1_verify","hash","signature","do_secp256k1_recover_pubkey","msgHash","recover_param","do_abort","message","read_str","do_debug","messageStr","do_ed25519_batch_verify","messages_ptr","signatures_ptr","public_keys_ptr","pubkeys_ptr","do_ed25519_verify","do_query_chain","request","resetDebugInfo","debugMsgs","chain","db","balances","recipient","senderBalance","ParsedCoin","fromCoin","filter","c","parsedCoins","hasCoin","recipientBalance","setBalance","toCoin","burn","balance","mint","storage","getObject","getBalances","deleteBalance","_","deleter","to_address","andThen","bankQuery","all_balances","lensFromSnapshot","BigInt","snapshot","emitter","callbacks","relayMap","middleWares","denomMap","getKey","ibcDenom","port","channel","toUtf8","toUpperCase","handleRelayMsg","bind","addMiddleWare","removeMiddelWare","chainMiddleWares","findInd","findIndex","splice","relay","sourceChannel","sourcePort","destChannel","destPort","destChain","innerRelay","getContractIbcPort","contractIbcPort","channelInfo","values","source_port_id","timer","appRes","endpoint","channel_id","ibcMsg","destDenom","token","startsWith","counterparty_endpoint","receiver","port_id","destContractAddress","substring","ret","handleIbcResponse","middleware","clearTimeout","delete","destInfo","send_packet","sendPacketReceive","packet","src","dest","relayer","timestamp","IbcOrder","Unordered","connection_id","msgData","channelId","transfer","sendTransfer","close_channel","sendChannelClose","close_init","sendMsg","eventKey","emit","removeAllListeners","addListener","sendChannelOpen","open_init","open_try","sendChannelConnect","open_ack","open_confirm","sourceInfo","close_confirm","sendPacketAck","original_packet","sendPacketTimeout","destEndpoint","_wasm","_vm","contractInfo","contractState","getStorage","backend_api","vm","build","instantiate","instantiateMsg","ContractNotFoundError","getExecutionEnv","fromRustResult","setStorage","dict","execute","executeMsg","migrate","reply","replyMsg","ibc_channel_open","ibcChannelOpenMsg","ibc_channel_connect","ibcChannelConnectMsg","ibc_channel_close","ibcChannelCloseMsg","ibc_packet_receive","ibcPacketReceiveMsg","ibc_packet_ack","ibcPacketAckMsg","ibc_packet_timeout","ibcPacketTimeoutMsg","currBackend","fromBinary","getContractStorage","valid","VmError","ErrImpl","GenericError","contracts","lastCodeId","lastInstanceId","contractStorage","setCodeInfo","forEach","Number","toObject","storeCode","unwrap","toFixed","chain_id","getContracts","Object","registerContractInstance","contractAddressHash","buildContractAddress","toBech32","tracebase","NEVER_IMMUTIFY","storeSnapshot","response","customEvent","buildAppResponse","subtraces","handleContractResponse","messages","newCodeId","subres","handleSubmsg","gas_limit","reply_on","ReplyOn","Success","Always","wrapReplyResponse","replyRes","errMsg","error","queryTrace","trace","new_code_id","smart","toBase64","ibc_port","pinned","pushTrace","details","protobufRoot","Root","fromJSON","nested","MsgInstantiateContractResponse","fields","lookupType","payload","event","attr","encode","finish","instanceId","writeUInt32BE","hasher","Sha256","update","th","digest","slice","appEvents","serde","standard","setSimple","list","toArray","mutable","__ownerID","deref","List","asMutable","Reference","asImmutable","keys","serializeAs","compress","deserializeAs","_data","path","TransactionalLens","cb","updater","catch","reason","prefix","coll","toImmutable","isCollection","curr","setIn","getIn","fromImmutable","deleteIn","ArrayBuffer","isView","freeze","isArrayLike","item","isList","prop","isRustResult","isTSResult","encoding","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}